<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC7515 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7515.xml">
<!ENTITY RFC7516 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7516.xml"> 
<!ENTITY RFC7517 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7517.xml">
<!ENTITY RFC7518 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7518.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<!-- <?rfc compact="yes" ?> -->
<?rfc subcompact="no" ?>
<rfc category="info" docName="draft-pei-opentrustprotocol-04.txt" ipr="trust200902"
  submissionType="IETF">
  <front>
    <title abbrev="OTrP">The Open Trust Protocol (OTrP)</title>

    <!-- Authors TBD consideration: one from each finding members for editing 
         responsibility and more in contributors -->

    <author fullname="Mingliang Pei" initials="M." surname="Pei">
      <organization>Symantec</organization>
      <address>
        <postal>
          <street>350 Ellis St</street>
          <city>Mountain View</city>
          <region>CA</region>
          <code>94043</code>
          <country>USA</country>
        </postal>
        <email>mingliang_pei@symantec.com</email>
      </address>
    </author>

    <author fullname="Nick Cook" initials="N." surname="Cook">
      <organization>Intercede</organization>
      <address>
        <postal>
          <street>St. Mary's Road, Lutterworth</street>
          <city>Leicestershire</city>
          <region>LE17</region>
          <code>4PS</code>
          <country>Great Britain</country>
        </postal>
        <email>nick.cook@intercede.com</email>
      </address>
    </author>

    <author fullname="Minho Yoo" initials="M." surname="Yoo">
      <organization>Solacia</organization>
      <address>
        <postal>
          <street>5F, Daerung Post Tower 2, 306 Digital-ro</street>
          <city>Seoul</city>
          <code>152-790</code>          
          <country>Korea</country>
        </postal>
        <email>paromix@sola-cia.com</email>
      </address>
    </author>

    <author fullname="Andrew Atyeo" initials="A." surname="Atyeo">
      <organization>Intercede</organization>
      <address>
        <postal>
          <street>St. Mary's Road, Lutterworth</street>
          <city>Leicestershire</city>
          <region>LE17</region>
          <code>4PS</code>
          <country>Great Britain</country>
        </postal>       
        <email>andrew.atyeo@intercede.com</email>
      </address>
    </author>
    
    <author fullname="Hannes Tschofenig" initials="H." surname="Tschofenig">
      <organization>ARM Ltd.</organization>
      <address>
        <postal>
          <street>110 Fulbourn Rd</street>
          <city>Cambridge</city>
          <region>CB1</region>
          <code>9NJ</code>
          <country>Great Britain</country>
        </postal>
        <email>Hannes.tschofenig@arm.com</email>
      </address>
    </author>
    
    <date month="July" year="2017" />
    <area>General</area>
    <workgroup>Internet Engineering Task Force</workgroup>
    <keyword>Open Trust</keyword>
    <abstract>
      <t>This document specifies the Open Trust Protocol (OTrP), a 
      protocol to install, update, and delete applications and to manage 
      security configuration in a Trusted Execution Environment (TEE).</t> 

      <t>TEEs are used in environments where security services should be
       isolated from a regular operating system (often called rich OS). This form of compartmentlization 
grants a smaller codebase access to security sensitive services and restricts
communication from the rich OS to those security services via mediated access.</t>
    </abstract>
  </front>

  <middle>
   <section anchor="introduction" title="Introduction">
      <t>The Trusted Execution Environment (TEE) concept has been designed and used to
      increase security by separating regular operating systems, also referred as Rich Execution Environment (REE), from security-sensitive 
       applications. In an TEE ecosystem, a 
      Trust Service Manager (TSM) is used to authorize manage
      keys and the Trusted Applications (TA) that run in a device.
      Different device vendors may use different TEE implementations. Different
      application providers may use different TSM providers. There arises a
      need of an open interoperable protocol that allows trustworthy TSM to
      manage Security Domains and contents running in different Trusted Execution
      Environment (TEE) of various devices.</t>

      <t>The Open Trust Protocol (OTrP) defines a protocol between a
      TSM and a TEE and relies on IETF-defined end-to-end security mechanisms, namely 
      JSON Web Encryption (JWE), JSON Web Signature (JWS), and JSON Web Key (JWK).</t>

    <!--  <t>Some deployed TEE and TSM implementations use symmetric key cryptography
        as the underlying security foundation and rely on a centralized database
        that holds these keys for every device that uses a TEE. This specification 
        follows a different design approach and makes use of public key cryptography
        at the expensive of slower performance but improved security.         
      </t>
--> 

<!-- 
      <t>The OTrP protocol uses standard certificates as trust anchors and
        establishes mutual trust among device firmware, TEE, TSM, and service
        providers. Thus it doesn't bear the constraint and security risk that
        a central device key database would expose.
      </t>
--> 
      
      <t>This specification assumes that a device that utilizes this specification 
      is equipped with a TEE and is pre-provisioned with a device-unique public/private key pair, 
      which is securely stored. This key pair is referred as the 'root of trust'. 
      A Service Provider (SP) uses such a device to run
      Trusted Applications (TA).</t>
      
      
      <t>A security domain is defined as the TEE representation of a service
        provider and is a logical space that contains the service provider's
        Trusted Applications. Each security domain requires the management operations
        of Trusted Applications (TAs) in the form of installation, update
        and deletion.
      </t>
      
      <t>The protocol builds on the following properties of the system:
        <list style="numbers">
          <t>The SP needs to determine security-relevant information of a device
          before provisioning information to a TEE. Examples include 
          the verification of the root of trust, the type of firmware 
          installed, and the type of TEE included in a device. 
          </t>
          <t>A TEE in a device needs to determine whether a SP or the TSM is authorized 
            to manage applications in the TEE. 
          </t>
          <t>Secure Boot must be able to ensure a TEE is genuine.</t>
        </list>
      </t>

      <t>This specification defines message payloads 
        exchanged between devices and a TSM but does not mandate a specific transport.
      </t>
    </section>

    <section title="Requirements Language">
      <t>
        The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in
        <xref target="RFC2119">RFC 2119</xref>.
      </t>
    </section>

    <section anchor="terms" title="Terminology">
      <section anchor="Subsection-Definitions" title="Definitions">
        <t>The definitions provided below are defined as used in this
          document.
          The same terms may be defined differently in other
          documents.
        </t>

        <t>
          <list hangIndent="4" style="hanging">
          <t hangText="Client Application:">
              An application running on a rich OS, such as an Android, 
Windows, or iOS  application, 
              provided by a SP. 
              <vspace blankLines="1" />
            </t>

            <t hangText="Device:">
              A physical piece of hardware that hosts
              symmetric key cryptographic modules
              <vspace blankLines="1" />
            </t>

            <t hangText="OTrP Agent:">
              An application running in the rich OS allowing communication 
              with the TSM and the TEE. 
              <vspace blankLines="1" />
            </t>

            <t hangText="Rich Application:">
              Alternative name of "Client
              Application". In this document we may
              use these two terms interchangably.
              <vspace blankLines="1" />
            </t>

            <t hangText="Rich Execution Environment (REE)">
              An environment that
              is provided and governed by a rich OS,
              potentially in conjunction
              with other supporting operating systems
              and hypervisors; it is
              outside of the TEE. This environment and
              applications running on
              it are considered un-trusted.
              <vspace blankLines="1" />
            </t>

            <t hangText="Secure Boot Module (SBM):">
              A firmware in a device
              that delivers secure boot functionality. It
              is also referred as
              Trusted Firmware (TFW) in this document.
              <vspace blankLines="1" />
            </t>

            <t hangText="Service Provider (SP):">
              An entity that wishes to supply Trusted 
              Applications to remote devices. A Service 
              Provider requires the help of a TSM in order 
              to provision the Trusted Applications to the devices.
              <vspace blankLines="1" />
            </t>

            <t hangText="Trust Anchor:">
              A root certificate that a module
              trusts. It is usually embedded in
              one validating module, and used
              to validate the trust of a remote
              entity's certificate.
              <vspace blankLines="1" />
            </t>

            <t hangText="Trusted Application (TA):">
              Application that runs in
              TEE.
              <vspace blankLines="1" />
            </t>

            <t hangText="Trusted Execution Environment (TEE):">
              An execution
              environment that runs alongside but isolated from an
              REE. A TEE
              has security capabilities and meets certain
              security-related
              requirements: It protects TEE assets from general
              software attacks,
              defines rigid safeguards as to data and
              functions that a program
              can access, and resists a set of defined
              threats. There are
              multiple technologies that can be used to
              implement a TEE, and
              the level of security achieved varies
              accordingly.
              <vspace blankLines="1" />
            </t>
          </list>
        </t>
      </section>

      <section title="Abbreviations">
        <t>
          <list hangIndent="8" style="hanging">
            <t hangText="CA">Certificate Authority</t>

            <t hangText="OTrP">Open Trust Protocol</t>

            <t hangText="REE">Rich Execution Environment</t>

            <t hangText="SD">Security Domain</t>

            <t hangText="SP">Service Provider</t>

            <t hangText="SBM">Secure Boot Module</t>

            <t hangText="TA">Trusted Application</t>

            <t hangText="TEE">Trusted Execution Environment</t>

            <t hangText="TFW">Trusted Firmware</t>

            <t hangText="TSM">Trusted Service Manager</t>
          </list>
        </t>
      </section>

    </section>

    <section anchor="model" title="OTrP Entities and Trust Model">
      <section anchor="components" title="System Components">
        <t>There are the following main components in this OTrP system.</t>

        <t>
          <list hangIndent="4" style="hanging">
            <t hangText="TSM:">The TSM is responsible for originating and
              coordinating lifecycle management activity on a particular TEE.
            </t>

            <t>A Trust Service Manager (TSM) is at the core to the protocol
              that manages device trust check on behalf of service providers
              for
              the ecosystem scalability. In addition to its device trust
              management for a service provider, the TSM provides Security
              Domain management and TA management in a device, in particularly,
              over-the-air update to keep Trusted Applications up to date and clean up
              when a version should be removed.

<vspace blankLines="1"/>
In the context of this specification, the term Trusted Application Manager (TAM) and TSM are synonymous.

            </t>

            <t hangText="Certificate Authority (CA):">Mutual trust between a device
              and a TSM as well as a
              Service Provider is based on certificates. A
              device embeds a list
              of root certificates, called Trust Anchors,
              from trusted
              Certificate Authorities that a TSM will be
              validated against. A
              TSM will remotely attest a device by checking
              whether a device
              comes with a certificate from a trusted CA.
            </t>
            <t hangText="TEE:">The TEE resides in the device chip security
              zone and
              is responsible for protecting applications from attack,
              enabling
              the application to perform secure operations
            </t>
            <t hangText="REE:">The REE, usually called device OS such as
              Android OS
              in a phone device, is responsible for enabling off
              device
              communications to be established between the TEE and TSM.
              OTrP
              does not require the device OS to be secure.
            </t>
            <t hangText="OTrP Agent:">An application in the REE that
              can relay
              messages between a Client Application and TEE.
            </t>
            <t hangText="Secure Boot:">Secure boot (for the purposes of OTrP)
              must enable
              authenticity checking of TEEs by the TSM.
            </t>
          </list>
        </t>

        <t>The OTrP establishes appropriate trust anchors to enable TEE and
          TSMs to communicate in a trusted way when performing lifecycle
          management transactions. The main trust relationships between the
          components are the following.
        </t>

        <t>
          <list hangIndent="4" style="numbers">
            <t>TSM must be able to ensure a TEE is genuine</t>
            <t>TEE must be able to ensure a TSM is genuine</t>
            <t>Secure Boot must be able to ensure a TEE is genuine</t>
          </list>
        </t>

      </section>

      <section anchor="teeanchors" title="Trusted Anchors in TEE">
        <t>The TEE in each device comes with a trust store that contains a
          whitelist of TSM's root CA certificates, which are called Trust
          Anchors. A TSM will be trusted to manage Security Domains and TAs
          in a
          device only if its certificate is chained to one of the root
          CA
          certificates in this trust store.
        </t>

        <t>Such a list is typically embedded in TEE of a device, and the list
          update is enabled and handled by device OEM provider.
        </t>
      </section>

      <section anchor="tsmanchors" title="Trusted Anchors in TSM">
        <t>The Trust Anchor set in a TSM consists of a list of Certificate
          Authority certificates that signs various device TEE certificates.
          A
          TSM decides what TEE and TFW it will trust.
        </t>
      </section>

      <section anchor="keytypes" title="Keys and Cerificate Types">
        <t>OTrP Protocol leverages the following list of trust anchors and
          identities in generating signed and encrypted command messages that
          are exchanged between a device with TEE and a TSM. With these
          security
          artifacts, OTrP Messages are able to deliver end-to-end
          security
          without relying on any transport security.
        </t>

<!--        <t>TBD - remove table to use hang list after further edit review.</t> -->

        <texttable anchor="keytypelist" title="Key and Certificate Types">
          <ttcol align='left'>Key Entity Name</ttcol>
          <ttcol align='left'>Location</ttcol>
          <ttcol align='left'>Issuer</ttcol>
          <ttcol align='left'>Trust Implication</ttcol>
          <ttcol align='left'>Cardinality</ttcol>

          <c>1. TFW keypair and Certificate</c>
          <c>Device secure storage</c>
          <c>OEM CA</c>
          <c>A white list of FW root CA trusted by TSMs</c>
          <c>1 per device</c>

          <c>2. TEE keypair and Certificate</c>
          <c>Device TEE</c>
          <c>TEE CA under a root CA</c>
          <c>A white list of TEE root CA trusted by TSMs</c>
          <c>1 per device</c>

          <c>3. TSM keypair and Certificate</c>
          <c>TSM provider</c>
          <c>TSM CA under a root CA</c>
          <c>A white list of TSM root CA embedded in TEE</c>
          <c>1 or multiple can be used by a TSM</c>

          <c>4. SP keypair and Certificate</c>
          <c>SP</c>
          <c>SP signer CA</c>
          <c>TSM manages SP. TA trust is delegated to TSM. TEE trusts TSM to
            ensure that a TA is trustworthy.
          </c>
          <c>1 or multiple can be used by a TSM</c>

        </texttable>

<!--        <t>******* TBD choose table or list view later *******</t> --> 

        <t>
          <list hangIndent="4" style="hanging">
            <t hangText="1. TFW keypair and Certificate:">A key pair and certificate
              for evidence of secure boot
              and trustworthy firmware in a device.
            </t>
            <t>
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">Device secure storage</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Issuer: ">OEM CA</t>
                <t hangText="Trust Implication: ">A white list of FW root CA trusted
                  by TSMs
                </t>
                <t hangText="Cardinality: ">One per device</t>
              </list>
            </t>

            <t hangText="2. TEE keypair and Certificate:">It is used for device
              attestation to remote TSM and
              SP.
            </t>

            <t>This key pair is burned into the device at device manufacturer.
              The key pair and its certificate are valid for the expected
              lifetime
              of the device.
            </t>
            <t>
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">Device TEE</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Issuer: ">TEE CA that chains to a root CA</t>
                <t hangText="Trust Implication: ">A white list of TEE root CA
                  trusted by TSMs
                </t>
                <t hangText="Cardinality: ">One per device</t>
              </list>
            </t>

            <t hangText="3. TSM keypair and Certificate:">A TSM provider acquires
              a certificate from a CA that a
              TEE trusts.
            </t>

            <t>
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">TSM provider</t>
                <t hangText="Supported Key Type: ">RSA and ECC.</t>
                <t hangText="Supported Key Size: ">RSA 2048-bit, ECC P-256
                  and P-384.
                </t>
                <t hangText="Issuer: ">TSM CA that chains to a root CA</t>
                <t hangText="Trust Implication: ">A white list of TSM root CA
                  embedded in TEE
                </t>
                <t hangText="Cardinality: ">One or multiple can be used by a TSM</t>
              </list>
            </t>

            <t hangText="4. SP keypair and Certificate:">A SP uses its own key pair
              and certificate to sign a
              TA.
            </t>
            <t>
              <list hangIndent="2" style="hanging">
                <t hangText="Location: ">SP</t>
                <t hangText="Supported Key Type: ">RSA and ECC</t>
                <t hangText="Supported Key Size: ">RSA 2048-bit, ECC P-256
                  and P-384
                </t>
                <t hangText="Issuer: ">SP signer CA that chains to a root CA</t>
                <t hangText="Trust Implication: ">TSM manages SP. TA trust is
                  delegated to TSM. TEE
                  trusts TSM to ensure that a TA is trustworthy.
                </t>
                <t hangText="Cardinality: ">One or multiple can be used by a SP</t>
              </list>
            </t>
          </list>
        </t>
      </section>
    </section>

    <section anchor="overview" title="Protocol Scope and Entity Relations">
      <t>This document specifies the minimally required interoperable artifacts
        to establish mutual trust between a TEE and TSM. The protocol provides
        specifications for the following three entities:
      </t>

      <t>
        <list style="numbers">
          <t>Key and certificate types required for device firmware, TEE, TA,
            SP,
            and TSM
          </t>
          <t>Data message formats that should be exchanged between a TEE in a
            device and a TSM
          </t>
          <t>An OTrP Agent application in the REE that can relay
            messages
            between a Client Application and TEE
          </t>
        </list>
      </t>

      <t>Figure 1: Protocol Scope and Entity Relationship</t>

      <t>
       <figure>
       <preamble></preamble>
       <artwork align="left"><![CDATA[
PKI    CA    --CA                                   CA--
        |    |                                         |
        |    |                                         |
        |    |                                         |
Device  |    |   ----OTrP Agent --- Rich App ---       |
SW      |    |   |                             |       |
        |    |   |                             |       |
        |    |   |                             |       |
OTrP    |    -- TEE                           TSM-------
        |
        |
       FW 
          ]]></artwork>
       </figure>
      </t>

      <t>Figure 2: OTrP System Diagram</t>

      <t>
       <figure>
       <preamble></preamble>
       <artwork align="left"><![CDATA[

              ---OTrP Message Protocol--
              |                        |
              |                        |
 --------------------           ---------------   ----------
 |  REE   |  TEE    |           |    TSM      |   |  SP    |
 |  ---   |  ---    |           |    ---      |   |  --    |
 |        |         |           |             |   |        |
 | Client | SD (TAs)|           |   SD / TA   |   |  TA    |
 |  Apps  |         |           |     Mgmt    |   |        |
 |   |    |         |           |             |   |        |
 |   |    |         |           |             |   |        |
 | OTrP   | Trusted |           |  Trusted    |   |        |
 | Agent  |  CAs    |           | FW, TEE CAs |   |        |
 |        |         |           |             |   |        |
 |        |TEE Key/ |           |  TSM Key/   |   |SP Key/ |
 |        |  Cert   |           |    Cert     |   | Cert   |
 |        | FW Key/ |           |             |   |        |
 |        |  Cert   |           |             |   |        |
 ------------------             ---------------   ----------
              |                        |              |
              |                        |              |
              -----------------------------------------
                                |
                                |
                          --------------
                          |    CA      |
                          --------------                                                 
          ]]></artwork>
       </figure>
      </t>

      <t>In the previous diagram, different Certificate Authorities can be used
        respectively for different types of certificates. OTrP Messages are
        always
        signed, where the signer keys is the message creator's key pair
        such as a
        FW key pair, TEE key pair or TSM key pair.
      </t>

      <t>The main OTrP Protocol component is the set of standard JSON messages
        created by TSM to deliver device SD and TA management commands to a
        device, and device attestation and response messages created by TEE to
        respond to TSM OTrP Messages.
      </t>

      <t>The communication method of OTrP Messages between a TSM and TEE in a
      device is left to TSM providers for maximal interoperability. A TSM can
      work with its SP and Client Applications how it gets OTrP Messages from a
      TSM. When a Client Application has had an OTrP Message from its TSM, it
      is imperative to have an interoperable interface to communicate with
      various TEE types. This is the OTrP Agent interface that serves this
      purpose. The OTrP Agent doesn't need to know the actual content of OTrP
      Messages except for the TEE routing information.
      </t>

      <section anchor="setupflow" title="A Sample Device Setup Flow">
          <t>Step 1: Prepare Images for Devices
            <list hangIndent="2" style="numbers">
              <t>[TEE vendor] Deliver TEE Image (CODE Binary)</t>
              <t>[CA]         Deliver root CA Whitelist</t>
              <t>[Soc]        Deliver TFW Image</t>
            </list>
          </t>
          <t></t>
          
          <t>Step 2: Inject Key Pairs and Images to Devices
            <list hangIndent="2" style="numbers">
              <t>[OEM] Generate Secure Boot Key Pair 
                       (May be shared among multiple devices)</t>
              <t>[OEM] Flash signed TFW Image and signed TEE Image 
                       onto devices (signed by Secure Boot Key)</t>
            </list>
          </t>
          <t></t>

          <t>Step 3: Setup attestation key pair in devices
            <list hangIndent="2" style="numbers">
              <t>[OEM]     Flash Secure Boot Public Key and eFuse Key
                           (eFuse key is unique per device)</t>
              <t>[TFW/TEE] Generate a unique attestation key pair and 
                           get a certificate for the device.</t>
            </list>
          </t>
          <t></t>

          <t>Step 4: Setup trust anchors in devices
            <list hangIndent="2" style="numbers">
              <t>[TFW/TEE] Store the key and certificate encrypted 
                           with the eFuse key</t>
              <t>[TEE vendor or OEM] Store trusted CA certificate list 
                           into devices</t>
            </list>
          </t>

      </section>

      <section anchor="derivedkeys" title="Derived Keys in the Protocol">
        <t>
          The protocol generates the following two key pairs in run time to
          assist
          message communication and anonymous verification between TSM
          and TEE.
        </t>

        <t>
          1. TEE Anonymous Key (TEE AIK): one derived key pair per TEE in a
          device
        </t>
        <t>
          The purpose of the key pair is to sign data by a TEE without using
          its TEE device key for anonymous attestation to a Client Application.
          This key is generated in the first GetDeviceState query. The public
          key of the key pair is returned to the caller Client Application for
          future TEE returned data validation.
        </t>
        <t>
          2. TEE SP AIK: one derived key per SP in a device
        </t>
        <t>
          The purpose of this key pair is for a TSM to encrypt TA binary data
          when it sends a TA to a device for installation. This key is
          generated in the first SD creation for a SP. It is deleted when all
          SDs are removed for a SP in a device.
        </t>
        <t>
          With the presence of a TEE SP AIK, it isn't necessary to have a
          shared SP
          independent TEE AIK. For the initial release, this
          specification will
          not use TEE AIK.
        </t>
      </section>

      <section anchor="sdtree" title="Security Domain Hierarchy and Ownership">
        <t>
          The primary job of a TSM is to help a SP to manage its trusted
          applications.
          A TA is typically installed in a SD. A SD is commonly
          created for a SP.
        </t>
        <t>
          When a SP delegates its SD and TA management to a TSM, a SD is
          created on behalf of a TSM in a TEE and the owner of the SD is
          assigned to the TSM. A SD may be associated with a SP but the TSM has
          full privilege to manage the SD for the SP.
        </t>
        <t>
          Each SD for a SP is associated with only one TSM. When a SP changes
          TSM, a new SP SD must be created to associate with the new TSM. TEE
          will maintain a registry of TSM ID and SP SD ID mapping.
        </t>
        <t>
          From a SD ownership perspective SD tree is flat and there is only one
          level. A SD is associated with its owner. It is up to TEE's
          implementation how it maintains SD binding information for TSM and
          different SPs under the same TSM.
        </t>
        <t>
          It is an important decision in this protocol specification that a TEE
          doesn't need to know whether a TSM is authorized to manage SD for a
          SP. This authorization is implicitly triggered by a SP Client
          Application, which instructs what TSM it wants to use. A SD is always
          associated with a TSM in addition to its SP ID. A rogue TSM isn't
          able to do anything on an unauthorized SP's SD managed by another TSM.
        </t>
        <t>
          Since a TSM may support multiple SPs, sharing the same SD name for
          different SP creates a dependency in deleting a SD. A SD can be
          deleted only after all TAs associated with this SD is deleted. A SP
          cannot delete a Security Domain on its own with a TSM if a TSM
          decides to introduce such sharing. There are cases where multiple
          virtual SPs belong to the same organization, and a TSM chooses to use
          the same SD name for those SPs. This is totally up to the TSM
          implementation and out of scope of this specification.
        </t>
      </section>

      <section anchor="sdownerid"
        title="SD Owner Identification and TSM 
     Certificate Requirements">
        <t>
          There is a need of cryptographically binding proof about the owner of
          a SD in device. When a SD is created on behalf of a TSM, a future
          request from the TSM must present itself as a way that the TEE can
          verify it is the true owner. The certificate itself cannot reliably
          used as the owner because TSM may change its certificate.
        </t>
        <t>
          To this end, each TSM will be associated with a trusted identifier
          defined as an attribute in the TSM certificate. This field is kept
          the same when the TSM renew its certificates. A TSM CA is responsible
          to vet the requested TSM attribute value.
        </t>
        <t>
          This identifier value must not collide among different TSM providers,
          and one TSM shouldn't be able to claim the identifier used by another
          TSM provider.
        </t>
        <t>
          The certificate extension name to carry the identifier can initially
          use SubjectAltName:registeredID. A dedicated new extension name may
          be registered later.
        </t>
        <t>
          One common choice of the identifier value is the TSM's service URL. A
          CA can verify the domain ownership of the URL with the TSM in the
          certificate enrollment process.
        </t>
        <t>
          TEE can assign this certificate attribute value as the TSM owner ID
          for the SDs that are created for the TSM.
        </t>
        <t>
          An alternative way to represent a SD ownership by a TSM is to have a
          unique secret key upon SD creation such that only the creator TSM is
          able to produce a Proof-of-Possession (POP) data with the secret.
        </t>
      </section>

      <section anchor="spcontainer" title="Service Provider Container">
        <!-- this paragraph is moved from word doc Implementation section into the 
          current entity section along with SD identificaton discussion. -->
        <t>A sample Security Domain hierarchy for the TEE is shown below.
        </t>
        <t>
            <figure>
              <artwork><![CDATA[
    ----------
    |  TEE   |
    ----------
        |
        |          ---------------
        |----------| SP1 Root SD |
        |          ---------------  
        |                 |
        |                 |          --------------
        |                 |----------| SP1 Sub SD |
        |                 |          --------------
        |                 |          --------------
        |                 |----------| SP1 Sub SD |
        |                            --------------
        |          ---------------
        |----------| SP2 Root SD |
                   ---------------        
             ]]></artwork>
            </figure>        
        </t>
        <t>The OTrP assumes that a SP managed by TSM1 cannot be managed by
          TSM2.
          Explicit permission grant should happen. SP can authorize TSM.
        </t>
      </section>
    </section>

    <section anchor="otrpagent" title="OTrP Agent">
      <t>OTrP Agent is an Rich Application or SDK that facilitates
      communication between a TSM and TEE. It also provides interfaces for TSM
      SDK or Client Applications to query and trigger TA installation that the
      application needs to use.
      </t>
      <t>
        This interface for Client Applications may be commonly an Android
        service call. A Client Application interacts with a TSM, and turns
        around to pass messages received from TSM to OTrP Agent.
      </t>
      <t>In all cases, a Client Application needs to be able to identify an
      OTrP Agent that it can use.
      </t>
      <section anchor="agentrole" title="Role of OTrP Agent">
        <t>
          OTrP Agent is responsible to communicate with TEE. It takes request
          messages from an application. The input data is mostly from a TSM
          that an application communicates. An application may also directly 
          call OTrP Agent for some TA query functions.
        </t>
        <t>
          OTrP Agent may internally process a request from TSM. At least, it
          needs to know where to route a message, e.g. TEE instance. It doesn't
          need to process or verify message content.
        </t>
        <t>
          OTrP Agent returns TEE / TFW generated response messages to the
          caller. OTrP Agent isn't expected to handle any network connection
          with an application or TSM.
        </t>
        <t>
          OTrP Agent only needs to return an OTrP Agent error message if the TEE
          is not reachable for some reason. Other errors are represented as response messages returned from the TEE which will then be passed to the TSM. 
        </t>
      </section>

      <section anchor="agentgp" title="OTrP Agent and Global Platform TEE Client API">
        <t>A Client Application may rely on Global Platform (GP) TEE API for TA communication.
          OTrP may use the GP TEE Client API but it is internal to OTrP
          implementation that converts given messages from TSM. More details can be found at 
<xref target="GPTEE"/>.
        </t>
      </section>

      <section anchor="agentimpl" title="OTrP Agent Implementation Consideration">
        <t>A Provider should consider methods of distribution, scope and
          concurrency on device and runtime options when implementing an OTrP
          Agent. Several non-exhaustive options are discussed below. Providers
          are encouraged to take advantage of the latest communication and
          platform capabilities to offer the best user experience.
        </t>
        <section title="OTrP Agent Distribution">
          <t>
            OTrP Agent installation is commonly carried out at OEM time. A
            user can
            dynamically download and install an OTrP Agent on-demand.
          </t>
          <t>
            It is important to ensure a legitimate OTrP Agent is installed and
            used. If an OTrP Agent is compromised it may send rogue messages to
            TSM and TEE and introduce additional risks.
          </t>
        </section>
        <section title="Number of OTrP Agent">

          <t>
            We anticipate only one shared OTrP Agent instance in a device. The
            device's TEE vendor will most probably supply one OTrP Agent.
            Potentially we expect some open source.
          </t>
          <t>
            With one shared OTrP Agent, the OTrP Agent provider is responsible
            to allow multiple TSMs and TEE providers to achieve
            interoperability. With a standard OTrP Agent interface, TSM can
            implement its own SDK for its SP Client Applications to work with
            this OTrP Agent.
          </t>
          <t>
            Multiple independent OTrP Agent providers can be used as long as
            they have standard interface to a Client Application or TSM SDK.
            Only one OTrP Agent is expected in a device.
          </t>
          <t>
            OTrP Protocol MUST specify a standard way for applications to
            lookup the active OTrP Agent instance in a device.
          </t>
          <t>
            TSM providers are generally expected to provide SDK for SP
            applications to interact with OTrP Agent for the TSM and TEE
            interaction.
          </t>
        </section>

        <section title="OTrP Android Service Option">
          <t>
            OTrP Agent can be a bound service in Android with a service
            registration ID that a Client Application can use. This option
            allows a Client Application not to depend on any OTrP Agent SDK or
            provider.
          </t>
          <t>
            An OTrP Agent is responsible to detect and work with more than one
            TEE if a device has more than one. In this version, there is only one
            active TEE such that an OTrP Agent only needs to handle the active
            TEE.
          </t>
        </section>
      </section>

      <section anchor="agentapi" title="OTrP Agent API for Client Applications">
        <t>A Client Application shall be responsible for relaying 
           messages between the OTrP agent and the TSM.
<!-- 
          A Client Application may commonly used to include target TSM contact
          information for the Trusted Applications it need to use. The
          application will rely on some TSM provided functions to communicate
          with its TSM.
-->
        </t>
        <t>
          OTrP Agent APIs are defined below. An OTrP Agent in the form of an
          Android bound service can take this to be the functionality it
          provides via service call. The OTrP Agent implements this interface.
        </t>
        <t>
          If a failure is occured during calling API, an error message
          described in "Common Errors" section (see <xref target="commerr"></xref>)
          will be returned.
        </t>

        <figure>
          <artwork><![CDATA[
interface IOTrPAgentService {
  String processMessage(String tsmInMsg) throws OTrPAgentException;
  String getTAInformation(String spid, String taid) 
     throws OTrPAgentException;
}

public class OTrPAgentException extends Throwable {
  private int errCode;
}
           ]]></artwork>
        </figure>

        <section title="API processMessage">
          <figure>
            <artwork><![CDATA[
String processMessage(String tsmInMsg) throws OTrPAgentException;
           ]]></artwork>
          </figure>

          <t>
            Description
            <list hangIndent="4" style="empty">
              <t>
                A Client Application will use this method of the OTrP Agent in
                a device to pass OTrP messages from a TSM. The method is
                responsible for interation with the TEE and for forwarding the 
                input message to the TEE. It also returns TEE generated response
                message back to the Client Application.
              </t>
            </list>
          </t>

          <t>
            Input
            <list hangIndent="4" style="empty">
              <t>tsmInMsg - OTrP message generated in a TSM that is passed to
              this method from a Client Application.
              </t>
            </list>
          </t>

          <t>
            Output
            <list hangIndent="4" style="empty">
              <t>A TEE generated OTrP response message (which may be a 
                 successful response or be a response message containing 
                 an error raised within the TEE) for the client application 
                 to forward to the TSM. In the event of the OTrP agent not 
                 being able to communicate with the TEE, a 
                 OTrPAgentException shall be thrown. 
              </t>
            </list>
          </t>
        </section>

        <section title="API getTAInformation">
          <figure>
            <artwork><![CDATA[
String getTAInformation(String spid, String taid) 
   throws OTrPAgentException;
]]></artwork>
          </figure>

          <t>
            Description
            <list hangIndent="4" style="empty">
              <t>
                A Client Application calls this method to query a TA's
                information. This method is carried out locally by the 
                OTrP Agent
                without relying on a TSM if it has had the TEE SP AIK.
              </t>
            </list>
          </t>

          <t>
            Input
            <!-- <list style="symbols"> -->
            <list hangIndent="4" style="empty">
              <t>spid - SP identifier of the TA</t>
              <t>taid - the identifier of the TA</t>
            </list>
          </t>

          <t>
            Output
            <list hangIndent="4" style="empty">
              <t>
                The API returns TA signer and TSM signer certificate along with
                other metadata information about a TA.
              </t>
              <t>
                The output is a JSON message that is generated by the TEE. It
                contains the following information:
                <list hangIndent="2" style="symbols">
                  <t>TSMID</t>
                  <t>SP ID</t>
                  <t>TA signer certificate</t>
                  <t>TSM certificate</t>
                </list>
                The message is signed with TEE SP AIK private key.
              </t>
              <t>
                The Client Application is expected to consume the response as
                follows.
              </t>
              <t>
                The Client Application gets signed TA metadata, in
                particularly, the TA signer certificate. It is able to verify
                that the result is from device by checking signer against TEE
                SP AIK public key it gets in some earlier interaction with TSM.
              </t>
              <t>
                If this is a new Client Application in the device that hasn't
                had TEE SP AIK public key for the response verification, the
                application can contact TSM first to do GetDeviceState, and
                TSM will return TEE SP AIK public key to the app for this
                operation to proceed.
              </t>
              <t>
                JSON Message
              </t>
              <t>
                <figure>
                  <artwork><![CDATA[
{
  "TAInformationTBS": {
    "taid": "<TA Identifier from the input>",
    "tsmid": "<TSM ID for the Security Domain where this TA 
              resides>",
    "spid": "<The service provider identifier of this TA>",
    "signercert": "<The BASE64 encoded certificate data of the TA
                   binary application's signer certificate>",
    "signercacerts": [ // the full list of CA certificate chain 
                       // including  the root CA
    "cacert": "<The BASE64 encoded CA certificate data of the TA 
                   binary application's signer certificate>"
    ],
    "tsmcert": "<The BASE64 encoded certificate data of the TSM that
                 manages this TA.>",
    "tsmcacerts": [ // the full list of CA certificate chain 
                    // including the root CA
    "cacert":"<The BASE64 encoded CA certificate data of the TSM
                  that manages this TA>"
    ]
  }
}

{
  "TAInformation": {
      "payload": "<BASE64URL encoding of the TAInformationTBS 
                  JSON above>",
      "protected": "<BASE64URL encoded signing algorithm>",
      "header": {
          "signer": {"<JWK definition of the TEE SP AIK public 
                      key>"}
      },
      "signature": "<signature contents signed by TEE SP AIK private
                    key BASE64URL encoded>"
  }
}
]]></artwork>
                </figure>
              </t>
              <t>
                A sample JWK public key representation refers to an example in
                <xref target="RFC7517">RFC 7517</xref>
                .
              </t>
            </list>
          </t>
        </section>

      </section>

      <section anchor="agentuse" title="Sample End-to-End Client Application Flow">
        <section title="Case 1: A new Client App uses a TA">
          <t>
            <list style="numbers">
              <t>
                During the Client App installation time, the Client App calls
                TSM to initialize device preparation
                <list style="letters">
                  <t>The Client Application knows it wants to use a TA1 
                    but the application doesn'tknow
                    whether TA1 has been installed or not. It can use GP
                    TEE Client
                    API to check the existence of TA1 first. If it
                    doesn't exist,
                    it will contact TSM to initiate the TA1
                    installation. Note that
                    TA1 could have been installed that
                    is triggered by other Client
                    Applications of the same
                    service provider in the same
                    device.
                  </t>
                  <t>The Client Application sends TSM the TA list that it depends on.
                    The
                    TSM will query a device for the Security Domains and TAs
                    that
                    have been installed, and instructs the device to
                    install any
                    dependent TAs that have not been installed.
                  </t>
                  <t>In general, TSM has the latest information of TA list and
                    their status in a device because all operations are
                    instructed
                    by TSM. TSM has such visibility because all
                    Security Domain
                    deletion and TA deletion are managed by TSM;
                    the TSM could have
                    stored the state when a TA is installed,
                    updated and deleted.
                    There is also the possibility that an update
                    command is carried out
                    inside TEE but a response is never
                    received in TSM. There is
                    also possibility that some manual
                    local reset is done in a
                    device that the TSM isn't aware of
                    the changes.
                  </t>
                </list>
              </t>
              <t>TSM generates message: GetDeviceStateRequest
              </t>
              <t>The Client Application passes the JSON message GetDeviceStateRequest
                to OTrP Agent API processMessage. The communication between a
                Client
                Application and OTrP Agent is up to the implementation of OTrP
                Agent.
              </t>
              <t>OTrP Agent routes the message to the active TEE.
                Multiple TEE case: it is up to OTrP Agent to figure this out.
                This specification limits the support to only one active TEE,
                which is the typical case today.
              </t>
              <t>The target active TEE processes the received OTrP message,
                returns a JSON message GetDeviceStateResponse
              </t>
              <t>The OTrP Agent passes the GetDeviceStateResponse to the Client
                App
              </t>
              <t>The Client Application sends GetDeviceStateResponse to TSM
              </t>
              <t>
                TSM processes GetDeviceStateResponse
                <list style="letters">
                  <t>Extract TEEspaik for the SP, signs TEEspaik with TSM
                    signer
                    key
                  </t>
                  <t>Examine SD list and TA list</t>
                </list>
              </t>
              <t>
                TSM continues to carry out other actions basing on the need.
                The
                next call could be instructing the device to install a
                dependent
                TA.
                <list style="letters">
                  <t>Assume a dependent TA isn't in the device yet, the TSM
                    may
                    do the following:
                  </t>
                  <t>
                    <list style="symbos">
                      <t>Create a SD to install the TA by sending a message
                        CreateSDRequest. The message is sent back to the
                        Client
                        Application, and then OTrP Agent and TEE to process.
                      </t>
                      <t>Install a TA with a message InstallTARequest.</t>
                    </list>
                  </t>
                  <t>If a Client Application depends on multiple TAs, the Client
                    Application
                    should expect multiple round trips of the TA
                    installation
                    message exchanges.
                  </t>
                </list>
              </t>
              <t>At the last TSM and TEE operation, TSM returns the signed
                TEE
                SP
                AIK public key to the application
              </t>
              <t>The Client Application shall store the TEEspaik for future
                loaded TA trust check purpose.
              </t>
              <t>If the TSM finds that this is a fresh device that does not 
                have any SD for the SP yet, then the TSM may move on to 
                create a SD for the SP next.
              </t>
              <t>During Client Application installation, the application
                checks
                whether required Trusted Applications are already installed,
                which may have been provided by TEE. If needed, it will contact
                its TSM service to determine whether the device is ready or
                install TA list that this application needs.
              </t>
            </list>
          </t>
        </section>

        <section title="Case 2: A previously installed Client Application calls a TA">
          <t>
            <list style="numbers">
              <t>The Client Application checks the device readiness: (a) whether it has
                a
                TEE; (b) whether it has TA that it depends. It may happen that
                TSM
                has removed TA this application depends on.
              </t>
              <t>The Client App calls OTrP Agent method "GetTAInformation"
              </t>
              <t>OTrP Agent queries the TEE to get TA information. If the given
                TA
                doesn't exist, an error is returned
              </t>
              <t>The Client App parses the TAInformation message.
              </t>
              <t>If the TA doesn't exist, the Client App calls its TSM to
                install
                the
                TA. If the TA exists, the Client App proceeds to call
                the TA.
              </t>
            </list>
          </t>
        </section>
      </section>
    </section>

    <section anchor="messages" title="OTrP Messages">
      <t>The main OTrP Protocol component is the set of standard JSON messages
        created by TSM to deliver device SD and TA management commands to a
        device, and device attestation and response messages created by TEE to
        respond to TSM OTrP Messages.
      </t>
      <t>
        An OTrP Message is designed to provide end-to-end security. It is always
        signed
        by its creator. In addition, an OTrP Message is typically
        encrypted
        such that only the targeted device TEE or TSM provider is able
        to
        decrypt and view the actual content.
      </t>
      <section anchor="format" title="Message Format">
        <t>OTrP Messages use JSON format for JSON's simple readability and
          moderate data size in comparison with alternative TLV and XML
          formats.
        </t>
        <t>
          JSON Message security has developed JSON Web Signing and JSON Web
          Encryption
          standard in the IETF Workgroup JOSE, see JWS <xref target="RFC7515"/> and JWE <xref target="RFC7516"/>.
          The OTrP
          Messages in this protocol will leverage the basic JWS and JWE
          to
          handle JSON signing and encryption.
        </t>
      </section>

      <section anchor="convention" title="Message Naming Convention">
        <t>For each TSM command "xyz"", OTrP Protocol use the following naming
          convention to represent its raw message content and complete request
          and response messages:
        </t>
        <texttable>
          <ttcol align="left">Purpose</ttcol>
          <ttcol align="left">Message Name</ttcol>
          <ttcol align="left">Example</ttcol>

          <c>Request to be signed</c>
          <c>xyzTBSRequest</c>
          <c>CreateSDTBSRequest</c>

          <c>Request message</c>
          <c>xyzRequest</c>
          <c>CreateSDRequest</c>

          <c>Response to be signed</c>
          <c>xyzTBSResponse</c>
          <c>CreateSDTBSResponse</c>

          <c>Response message</c>
          <c>xyzResponse</c>
          <c>CreateSDResponse</c>
        </texttable>

      </section>

      <section anchor="template" title="Request and Response Message Template">
        <figure>
          <preamble>An OTrP Request message uses the following format:
          </preamble>

          <artwork><![CDATA[
  {
    "<name>TBSRequest": {
      <request message content>
    }
  }
           ]]></artwork>
        </figure>

        <figure>
          <preamble>A corresponding OTrP Response message will be as follows.
          </preamble>

          <artwork><![CDATA[
  {
    "<name>TBSResponse": {
      <response message content>
    }
  }
           ]]></artwork>
        </figure>

      </section>

      <section anchor="signedmsg" title="Signed Request and Response Message Structure">
        <t>
          A signed request message will generally include only one signature,
          and uses the flattened JWS JSON Serialization Syntax, see Section
          7.2.2 in
          <xref target="RFC7515">RFC7515</xref>
          .
        </t>
        <figure>
          <preamble>A general JWS object looks like the following.
          </preamble>

          <artwork><![CDATA[
{
  "payload": "<payload contents>",
  "protected":"<integrity-protected header contents>",
  "header": {
    <non-integrity-protected header contents>,
  },
  "signature":"<signature contents>"
}
           ]]></artwork>
        </figure>

        <t>OTrP signed messages only requires the signing algorithm as the
          mandate header in the property "protected". The
          "non-integrity-protected header contents" is optional.
        </t>
        <t>
          OTrP signed message will be given an explicit Request or Response
          property
          name. In other words, a signed Request or Response uses the
          following
          template.
        </t>
        <figure>
          <preamble>A general JWS object looks like the following.
          </preamble>

          <artwork><![CDATA[
{
  "<name>[Request | Response]": {
    <JWS Message of <name>TBS[Request | Response]
  }
}
           ]]></artwork>
        </figure>

        <t>With the standard JWS message format, a signed OTrP Message looks
          like the following.
        </t>
        <figure>
          <artwork><![CDATA[
{
  "<name>[Request | Response]": {
    "payload": "<payload contents of <name>TBS[Request | Response]>",
    "protected":"<integrity-protected header contents>",
    "header":  <non-integrity-protected header contents>,
    "signature":"<signature contents>"
  }
}
           ]]></artwork>
        </figure>

        <t>
          The top element "
          &lt;name&gt;[Signed][Request | Response]" cannot be
          fully trusted to match
          the content because it doesn't participate the
          signature
          generation. However, a recipient can always match it with
          the value
          associated with the property "payload". It purely serves to
          provide
          a quick reference for reading and method invocation.
        </t>
        <t>Furthermore, most properties in an unsigned OTrP messages are
          encrypted to provide end-to-end confidentiality. The only OTrP message
          that isn't encrypted is the initial device query message that asks
          for the device state information.
        </t>
        <t>Thus a typical OTrP Message consists of an encrypted and then signed
          JSON message. Some transaction data such as transaction ID and TEE
          information may need to be exposed to OTrP Agent for routing purpose.
          Such information is excluded from JSON encryption. The device's
          signer certificate itself is encrypted. The overall final message is
          a standard signed JSON message.
        </t>
        <t>As required by JSW/JWE, those JWE and JWS related elements will be
          BASE64URL encoded. Other binary data elements specific to the OTrP
          specification are BASE64 encoded. This specification will identify
          elements that should be BASE64 and those elements that are to be
          BASE64URL encoded.
        </t>

        <section
          title="Identifying signing and Encryption keys for JWS/JWE messaging">
          <t>
            JWS and JWE messaging allow various options for identifying the
            signing and
            encryption keys, for example, it allows optional
            elements including
            "x5c", "x5t" and "kid" in the header to cover
            various
            possibilities.
          </t>
          <t>
            In order to protect privacy, it is important that the device's
            certificate
            is released only to a trusted TSM, and that it is
            encrypted. The
            TSM will need to know the device certificate, but
            untrusted parties
            must not be able to get the device certificate.
            All OTrP messaging conversations between a TSM and device begin
            with
            GetDeviceStateRequest / GetDeviceStateResponse. These messages
            have
            elements built into them to exchange signing certificates,
            described in the "Detailed Message Specification" section. Any
            subsequent messages in the conversation that follow on from this
            are implicitly using the same certificates for signing/encryption,
            and as a result the certificates or references 
            may be ommitted in those subsequent messages.
          </t>
          <t>
            In other words, the signing key identifier in the use of JWS and
            JWE here
            may be absent in the subsequent messages after the initial
            GetDeviceState query.
          </t>
          <t>
            This has implication on the TEE and TSM implementation: they
            have to cache the signer certificates for the subsequent
            message signature validation in the session. It may be easier
            for a TSM service to cache transaction session information
            but not so for a TEE in a device. A TSM should check a
            device's capability to decide whether it should include its
            TSM signer certificate and OCSP data in each subsequent
            request message. The device's caching capability is reported
            in GetDeviceStateResponse signerreq parameter.
          </t>
        </section>
      </section>

      <section title="JSON Signing and Encryption Algorithms">
        <t>
          The OTrP JSON signing algorithm shall use SHA256 or a stronger
          hash method with respective key type. JSON Web Algorithm RS256
          or ES256 <xref target="RFC7518"/> SHALL be used for RSA with SHA256 and
          ECDSA with SHA256. If RSA with SHA256 is used, the JSON web
          algorithm representation is as follows.
        </t>

        <t>
          <list hangIndent="4" style="empty">
            <t>{"alg":"RS256"}</t>
          </list>
        </t>

        <t>
          The (BASE64URL encoded) "protected" header property in a signed
          message looks like the following:
          <list hangIndent="4" style="empty">
            <t>"protected":"eyJhbGciOiJSUzI1NiJ9"</t>
          </list>
        </t>

        <t>
          If ECSDA with P-256 curve and SHA256 are used for signing, the JSON
          signing algorithm representation is as follows.

          <list hangIndent="4" style="empty">
            <t>{"alg":"ES256"}</t>
          </list>
        </t>

        <t>
          The value for the "protected" field will be the following.
          <list hangIndent="4" style="empty">
            <t>eyJhbGciOiJFUzI1NiJ9</t>
          </list>
        </t>

        <figure>
          <preamble>Thus a common OTrP signed message with ES256 looks like the
            following.
          </preamble>
          <artwork><![CDATA[
  {
    "payload": "<payload contents>",
     "protected": "eyJhbGciOiJFUzI1NiJ9",
    "signature":"<signature contents>"
  }
           ]]></artwork>
        </figure>

        <t>The OTrP JSON message encryption algorithm should use one of the
          supported algorithms defined in the later chapter of this document.
          JSON encryption uses a symmetric key as its "Content Encryption Key
          (CEK)". This CEK is encrypted or wrapped by a recipient's key. OTrP
          recipient typically has an asymmetric key pair. Therefore CEK will be
          encrypted by the recipient's public key.
        </t>

        <t>
          Symmetric encryption shall use the following algorithm.
          <list hangIndent="4" style="empty">
            <t>{"enc":"A128CBC-HS256"}</t>
          </list>
        </t>

        <t>
          This algorithm represents encryption with AES 128 in CBC mode with
          HMAC SHA 256 for integrity. The value of the property "protected" in
          a JWE message will be
          <list hangIndent="4" style="empty">
            <t>eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0</t>
          </list>
        </t>

        <figure>
          <preamble>An encrypted JSON message looks like the following.
          </preamble>

          <artwork><![CDATA[
  {
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
     "recipients": [
        {
            "header": {
                "alg": "<RSA1_5 etc.>"
            },
            "encrypted_key": "<encrypted value of CEK>"
        } 
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON plaintext 
                   (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
  }
           ]]></artwork>
        </figure>

        <t>OTrP doesn't use JWE AAD (Additional Authenticated Data) because
          each message is always signed after the message is encrypted.
        </t>

        <section anchor="signalgs" title="Supported JSON Signing Algorithms">
          <t>
            The following JSON signature algorithm are mandatory support in TEE
            and TSM:
            <list hangIndent="4" style="symbols">
              <t>RS256</t>

            </list>
          </t>
<t>ES256 is optional to support. </t>
        </section>

        <section anchor="encalgs" title="Support JSON Encryption Algorithms">
          <t>
            The following JSON authenticated encryption algorithm is mandatory
            support in TEE and TSM.
            <list hangIndent="4" style="symbols">
              <t>A128CBC-HS256</t>

            </list>
          </t>
              <t>A256CBC-HS512 is optional to support.</t>
        </section>

        <section anchor="kmalgs" title="Supported JSON Key Management Algorithms">
          <t>
            The following JSON key management algorithm is mandatory
            support in TEE and TSM.
            <list hangIndent="4" style="symbols">
              <t>RSA1_5</t>
            </list>
          </t>

          <t>ECDH-ES+A128KW and ECDH-ES+A256KW are optional to support.</t>
        </section>

      </section>

      <section anchor="commerr" title="Common Errors">
        <t>
          An OTrP Response message typically needs to report operation status
          and
          error causes if an operation fails. The following JSON message
          elements should be used across all OTrP Messages.
        </t>

        <figure>
          <artwork><![CDATA[
"status": "pass | fail"

 "reason": {
     "error-code": "<error code if there is any>",
     "error-message": "<error message>"
  }


"ver": "<version string>"
           ]]></artwork>
        </figure>

      </section>

      <section title="OTrP Message List">
        <t>
          The following table lists the OTrP commands and therefore
          corresponding Request and Response messages defined in this
          specification. Additional messages may be added in the future
          when new task messages are needed.
        </t>
        <t>
          <list hangIndent="4" style="hanging">
            <t hangText="GetDeviceState - ">
              <vspace blankLines="0" />
              A TSM queries a device's current state with a message
              GetDeviceStateRequest. A device TEE will report its
              version, its FW version, and list of all SD and TA in the
              device that is managed by the requesting TSM. TSM may
              determine whether the device is trustworthy and decide to
              carry out additional commands according to the response
              from this query.
            </t>
            <t hangText="CreateSD - ">
              <vspace blankLines="0" />
              A TSM instructs a device TEE to create a SD for a SP. The
              recipient TEE will check whether the requesting TSM is
              trustworthy.
            </t>
            <t hangText="UpdateSD - ">
              <vspace blankLines="0" />
              A TSM instructs a device TEE to update an existing SD. A
              typical update need comes from SP certificate change, TSM
              certificate change and so on. The recipient TEE will verify
              whether the TSM is trustworthy and owns the SD.
            </t>
            <t hangText="DeleteSD - ">
              <vspace blankLines="0" />
              A TSM instructs a device TEE to delete an existing SD. A
              TEE conditionally deletes TAs loaded in the SD according to
              a request parameter. A SD cannot be deleted until all TAs
              in this SD are deleted. If this is the last SD for a SP,
              TEE can also delete TEE SP AIK key for this SP.
            </t>
            <t hangText="InstallTA - ">
              <vspace blankLines="0" />
              A TSM instructs a device to install a TA into a SD for a
              SP. TEE in a device will check whether the TSM and TA are
              trustworthy.
            </t>
            <t hangText="UpdateTA - ">
              <vspace blankLines="0" />
              A TSM instructs a device to update a TA into a SD for a SP.
              The change may commonly be bug fix for a previously
              installed TA.
            </t>
            <t hangText="DeleteTA - ">
              <vspace blankLines="0" />
              A TSM instructs a device to delete a TA. TEE in a device
              will check whether the TSM and TA are trustworthy.
            </t>
          </list>
        </t>
      </section>

      <section title="OTrP Request Message Routing Rules">
        <t>
          For each command that a TSM wants to send to a device, the TSM
          generates a request message. This is typically triggered by a
          Client Application that uses the TSM. The Client Application
          initiates contact with the TSM and receives TSM OTrP Request
          messages according to the TSM's implementation. The Client
          Application forwards the OTrP message to an OTrP Agent in the
          device, which in turn sends the message to the active TEE in
          the device.
        </t>
        <t>The current version of specification assumes that each device has
          only one active TEE, and OTrP Agent is responsible to connect to the
          active TEE. This is the case today with devices in the market.
        </t>
        <t>Upon TEE responding with a request, the OTrP Agent gets OTrP
          response messages back to the Client Application that sends the
          request. In case the target TEE fails to respond the request, the
          OTrP Agent will be responsible to generate an error message to reply
          the Client Application. The Client Application forwards any data it
          received to its TSM.
        </t>

        <section title="SP Anonymous Attestation Key (SP AIK)">
          <t>When the first new Security Domain is created in TEE for a SP, 
            a new key pair
            is generated and associated with this SP. This key pair is used for
            future device attestation to the service provider instead of using
            device's TEE key pair.
          </t>

        </section>
      </section>
    </section>

    <section anchor="detailmsg" title="Detailed Messages Specification">
      <t>For each message in the following sections all JSON elements are
        mandatory if it isn't explicitly indicated as optional.
      </t>
      <section anchor="getdevicestate" title="GetDeviceState">
        <t>
          This is the first command that a TSM will query a device. This
          command is triggered when a SP's Client Application contacts
          its TSM to check whether the underlying device is ready for TA
          operations.
        </t>
        <t>
          This command queries a device's current TEE state. A device TEE
          will report its version, its FW version, and list of all SD and
          TA in the device that is managed by the requesting TSM. TSM may
          determine whether the device is trustworthy and decide to carry
          out additional commands according to the response from this
          query.
        </t>
        <t>
          The request message of this command is signed by TSM. The
          response message from TEE is encrypted. A random message
          encryption key (MK) is generated by TEE, and this encrypted key
          is encrypted by the receiving TSM public key such that only the TSM who
          sent the request is able to decrypt and view the response
          message.
        </t>

        <section anchor="getdsreq" title="GetDeviceStateRequest message">

          <figure>
            <artwork><![CDATA[
{
   "GetDeviceStateTBSRequest": {
      "ver": "1.0",
      "rid": "<Unique request ID>",
      "tid": "<transaction ID>",
      "ocspdat": "<OCSP stapling data of TSM certificate>",
      "icaocspdat": "<OCSP stapling data for TSM CA certificates>",
      "supportedsigalgs": "<comma separated signing algorithms>"
    }
}
           ]]></artwork>
          </figure>

          <t>
            The request message consists of the following data elements:
            <list hangIndent="4" style="hanging">
              <t hangText="ver - ">version of the message format</t>
              <t hangText="rid - ">a unique request ID generated by the TSM</t>
              <t hangText="tid - ">a unique transaction ID to trace request and
                response. This can be from a prior transaction's tid field, and
                can be used in the subsequent message exchanges in this TSM
                session. The combination of rid and tid should be made unique.
              </t>
              <t hangText="ocspdat - ">OCSP stapling data for the TSM certificate. The TSM
                provides OCSP data such that a recipient TEE can validate the
                validity of the TSM certificate without making its own external
                OCSP service call. This is a mandate field.
              </t>
              <t hangText="icaocspdat - ">OCSP stapling data for the intermediate CA
                certificates of the TSM certificate up to the root. A TEE side
                can cache CA OCSP data such that this value isn't needed in
                each call.
              </t>
              <t hangText="supportedsigalgs - ">an optional property to list the signing algorithms
                that TSM is able to support. A recipient TEE should choose
                algorithm in this list to sign its response message if this
                property is present in a request.
              </t>
            </list>
          </t>

          <figure>
            <preamble>The final request message is JSON signed message
            of the above raw JSON data with TSM's certificate.
            </preamble>

            <artwork><![CDATA[
{
  "GetDeviceStateRequest": {
    "payload":"<BASE64URL encoding of the GetDeviceStateTBSRequest
               JSON above>",
    "protected": "<BASE64URL encoded signing algorithm>",
    "header": {
        "x5c": "<BASE64 encoded TSM certificate chain up to the 
                root CA certificate>"
    },
    "signature":"<signature contents signed by TSM private key>"
  }
}
          ]]></artwork>
          </figure>

          <t>The signing algorithm should use SHA256 with respective key
            type. The mandatory algorithm support is the RSA signing
            algorithm. The signer header "x5c" is used to include the TSM
            signer certificate up to the root CA certificate.
          </t>

        </section>
        
        <section title="Request processing requirements at a TEE">
          <t> Upon receiving a request message GetDeviceStateRequest at a
          TEE, the TEE must validate a request:
          
            <list hangIndent="2" style="numbers">
              <t>Validate JSON message signing</t>
              <t>Validate that the request TSM certificate is chained to a
              trusted CA that the TEE embeds as its trust anchor.
                <list hangIndent="2" style="symbols">
                  <t>Cache the CA OCSP stapling data and certificate
                  revocation check status for other subsequent requests.
                  </t>
                  <t>A TEE can use its own clock time for the OCSP stapling
                  data validation. </t>
                </list></t>
              <t>Collect Firmware signed data
                <list hangIndent="2" style="symbols">
                  <t>This is a capability in ARM architecture that allows a
                  TEE to query Firmware to get FW signed data. </t>
                </list></t>
              <t>Collect SD information for the SD owned by this TSM</t>
            </list>
          </t>
        </section>

        <section title="Firmware signed data">
          <t> Firmware isn't expected to process or produce JSON data. It
          is expected to just sign some raw bytes of data.</t>
          
          <t>The data to be signed by TFW key needs be some unique random
          data each time. The (UTF-8 encoded) "tid" value from the
          GetDeviceStateTBSRequest shall be signed by the firmware. TSM
          isn't expected to parse TFW data except the signature
          validation and signer trust path validation.
          </t>

          <t>It is possible that a TEE can get some valid TFW signed data
          from another device. This is part of the TEE trust assumption
          where TSM will trust the TFW data supplied by the TEE. The TFW
          trust is more concerned by TEE than a TSM where a TEE needs to
          ensure that the underlying device firmware is trustworthy.
          </t>
          <figure>
            <artwork><![CDATA[          
  TfwData: {
       "tbs": "<TFW to be signed data, BASE64 encoded>",
       "cert": "<BASE64 encoded TFW certificate>",
       "sigalg": "Signing method",
       "sig": "<Tfw signed data,  BASE64 encoded>"
  }
           ]]></artwork>
          </figure>

          <t>It is expected that FW use a standard signature methods for
          maximal interoperability with TSM providers. The mandatory
          support list of signing algorithm is RSA with SHA256. 
          </t>

          <t>The JSON object above is constructed by TEE with data
          returned from FW. It isn't a standard JSON signed object. The
          signer information and data to be signed must be specially
          processed by TSM according to definition given here. The data
          to be signed is the raw data.
          </t>

          <section title="Supported Firmware Signature Methods">
            <t>TSM providers shall support the following signature
            methods. A firmware provider can choose one of the methods in
            signature generation.
              <list hangIndent="2" style="symbols">
                <t>RSA with SHA256</t>
                <t>ECDSA with SHA 256</t>
              </list></t>

            <t>The value of "sigalg" in the TfwData JSON message should use
            one of the following:
              <list hangIndent="2" style="symbols">
                <t>RS256</t>
                <t>ES256</t>
              </list>
            </t>
          </section>                        
        </section>

        <section title="Post Conditions">
          <t>Upon successful request validation, the TEE information is
          collected. There is no change in the TEE in the device.
          </t>

          <t>The response message shall be encrypted where the encryption
          key shall be a symmetric key that is wrapped by TSM's public
          key. The JSON Content Encryption Key (CEK) is used for this
          purpose.
          </t>
        </section>                        

        <section anchor="getdsresp" title="GetDeviceStateResponse message">
          <t>The message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
  { 
    "GetDeviceTEEStateTBSResponse": {
        "ver": "1.0",
        "status": "pass | fail",
        "rid": "<the request ID from the request message>",
        "tid": "<the transaction ID from the request message>",
        "signerreq": "true | false about whether TSM needs to send 
                      signer data again in subsequent messages",
        "edsi": "<Encrypted JSON dsi information>"
    }
 }
           ]]></artwork>
          </figure>

          <t>
            where
            <list hangIndent="4" style="hanging">
              <t hangText="signerreq - ">true if the TSM should send its
              signer certificate and OCSP data again in the subsequent
              messages. The value may be "false" if the TEE caches the
              TSM's signer certificate and OCSP status.</t>
              <t hangText="rid - ">the request ID from the request message</t>
              <t hangText="tid - ">the tid from the request message</t>
              <t hangText="edsi - ">the main data element whose value is
              JSON encrypted message over the following Device State
              Information (DSI).</t>
            </list>
          </t>


          <t>The Device State Information (DSI) message consists of the 
          following.</t>
<t>
          <figure>
            <artwork><![CDATA[
{
    "dsi": {
        "tfwdata": {
            "tbs": "<TFW to be signed data is the tid>"
            "cert": "<BASE64 encoded TFW certificate>",
            "sigalg": "Signing method",  
            "sig": "<Tfw signed data,  BASE64 encoded>"
        },
        "tee": {
            "name": "<TEE name>",
            "ver": "<TEE version>",
            "cert": "<BASE64 encoded TEE cert>",
            "cacert": "<JSON array value of CA certificates up to 
                        the root CA>",
            "sdlist": {
                "cnt": "<Number of SD owned by this TSM>",
                "sd": [
                    {
                        "name": "<SD name>",
                        "spid": "<SP owner ID of this SD>",
                        "talist": [
                          {
                             "taid": "<TA application identifier>",
                             "taname": "<TA application friendly 
                                       name>" // optional
                          }
                        ]
                    }
                ] 
            },
            "teeaiklist": [
                {
                    "spaik": "<SP AIK public key, BASE64 encoded>",
                    "spaiktype": "<RSA | ECC>",
                    "spid": "<sp id>"
                }
            ]
        }
    }
} 
           ]]></artwork>
          </figure>
</t> 

          <t>The encrypted JSON message looks like the following.</t>

          <figure>
            <artwork><![CDATA[
{
    "protected": "<BASE64URL encoding of encryption algorithm header 
                   JSON data>",
    "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        } 
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi 
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>Assume we encrypt plaintext with AES 128 in CBC mode with
          HMAC SHA 256 for integrity, the encryption algorithm header is:
            <list hangIndent="4" style="empty">
              <t>{"enc":"A128CBC-HS256"}</t>
            </list>
          </t>

          <t>The value of the property "protected" in the above JWE
          message will be
            <list hangIndent="4" style="empty">
              <t>eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0</t>
            </list>
          </t>

          <t>In other words, the above message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
     "recipients": [
        {
            "header": {
                "alg": "RSA1_5"
            },
            "encrypted_key": "<encrypted value of CEK>"
        } 
    ],
    "iv": "<BASE64URL encoded IV data>",
    "ciphertext": "<Encrypted data over the JSON object of dsi 
                    (BASE64URL)>",
    "tag": "<JWE authentication tag (BASE64URL)>"
}
           ]]></artwork>
          </figure>

          <t>The full response message looks like the following:</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateTBSResponse": {
    "ver": "1.0",
    "status": "pass | fail",
    "rid": "<the request ID from the request message>",
    "tid": "<the transaction ID from the request message>",
    "signerreq": "true | false", 
    "edsi": {
      "protected": "<BASE64URL encoding of encryption algorithm 
                     header JSON data>",
      "recipients": [
        {
          "header": {
            "alg": "RSA1_5"
          },
          "encrypted_key": "<encrypted value of CEK>"
        }
      ],
      "iv": "<BASE64URL encoded IV data>",
      "ciphertext": "<Encrypted data over the JSON object of dsi
                      (BASE64URL)>",
      "tag": "<JWE authentication tag (BASE64URL)>"
    }
  }
}
           ]]></artwork>
          </figure>

          <t>The CEK will be encrypted by the TSM public key in the
          device. The TEE signed message has the following structure.</t>
          <figure>
            <artwork><![CDATA[
{
  "GetDeviceTEEStateResponse": {
    "payload": "<BASE64URL encoding of the JSON message 
                 GetDeviceTEEStateTBSResponse>",
    "protected": "<BASE64URL encoding of signing algorithm>",
    "signature": "<BASE64URL encoding of the signature value>"
  }
}
           ]]></artwork>
          </figure>

          <t>The signing algorithm shall use SHA256 with respective key
          type, see Section <xref target="signalgs"></xref>.
          </t>
          <t>The final response message GetDeviceStateResponse consists
          of array of TEE response. A typical device will have only one
          active TEE. An OTrP Agent is responsible to collect TEE
          response for all active TEEs in the future.
          </t>

          <figure>
            <artwork><![CDATA[
{
    "GetDeviceStateResponse": [ // JSON array 
       {"GetDeviceTEEStateResponse": ...},
       ...
       {"GetDeviceTEEStateResponse": ...}
    ]    
}
           ]]></artwork>
          </figure>
        </section>

        <section title="Error Conditions">
          <t>An error may occur if a request isn't valid or the TEE runs into some error. The list of possible error conditions is the following.
            <list hangIndent="2" style="hanging">
            <t hangText="ERR_REQUEST_INVALID">The TEE meets the following
            conditions with a request message: (1) The request from a TSM
            has an invalid message structure; mandatory information is
            absent in the message. undefined member or structure is
            included.  (2) TEE fails to verify signature of the message
            or fails to decrypt its contents. (3) etc.</t>
            <t hangText="ERR_UNSUPPORTED_MSG_VERSION">TEE receives the
            version of message that TEE can't deal with.</t>
            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG">TEE receives a
            request message encoded with cryptographic algorithms that
            TEE doesn't support.</t>
            <t hangText="ERR_TFW_NOT_TRUSTED">TEE may consider the
            underlying device firmware be not trustworthy.</t>
            <t hangText="ERR_TSM_NOT_TRUSTED">TEE needs to make sure
            whether the TSM is trustworthy by checking the validity of
            TSM certificate and OCSP stapling data and so on. If TEE
            finds TSM is not reliable, it may return this error code.</t>
            <t hangText="ERR_TEE_FAIL">TEE fails to respond to a TSM
            request. The OTrP Agent will construct an error message in
            responding the TSM's request. And also if TEE fails to
            process a request because of its internal error, it will
            return this error code.</t>            
          </list></t>

          <t>The response message will look like the following if the TEE
          signing can work to sign the error response message.
          </t>
          <figure>
            <artwork><![CDATA[          
  {
      "GetDeviceTEEStateTBSResponse": {
          "ver": "1.0",
          "status": "fail",
          "rid": "<the request ID from the request message>",
          "tid": "<the transaction ID from the request message>",
          "reason": {"error-code":"<error code>"}
          "supportedsigalgs": "<signature algorithms TEE supports>"
      }
  }
           ]]></artwork>
          </figure>

          <t>where
            <list hangIndent="4" style="hanging">
              <t hangText="supportedsigalgs -">an optional property to
              list the JWS signing algorithms that the active TEE 
              supports. When a TSM sends a signed message that the TEE isn't
              able to validate, it can include signature algorithms that
              it is able to consume in this status report. A TSM can
              generate a new request message to retry the management task
              with a TEE supported signing algorithm.</t>
            </list></t>          

          <t>If TEE isn't able to sign an error message, a general error
          message should be returned.
          </t>
        </section>

        <section title="TSM Processing Requirements">
          <t>Upon receiving a message of the type GetDeviceStateResponse
          at a TSM, the TSM should validate the following.          
            <list hangIndent="2" style="symbols">
              <t>Parse to get list of GetDeviceTEEStateResponse JSON
              object</t>
              <t>Parse the JSON "payload" property and decrypt the JSON
              element "edsi"</t>
              <t>The decrypted message contains the TEE signer
              certificate</t>
              <t>Validate GetDeviceTEEStateResponse JSON signature. The
              signer certificate is extracted from the decrypted message
              in the last step.</t>
              <t>Extract TEE information and check it against its TEE
              acceptance policy.</t>
              <t>Extract TFW signed element, and check the signer and
              data integration against its TFW policy</t>
              <t>Check the SD list and TA list and prepare for a
              subsequent command such as "CreateSD" if it needs to have a
              new SD for a SP.</t>
            </list>
          </t>
        </section>
                            
      </section> <!-- Get Device State -->

      <section anchor="sdmgmt" title="Security Domain Management">
        <section anchor="createsd" title="CreateSD">
          <t>This command is typically preceded with GetDeviceState
          command that has acquired the device information of the target
          device by the TSM. TSM sends such a command to instruct a TEE
          to create a new Security Domain for a SP.
          </t>

          <t>A TSM sends an OTrP Request message CreateSDRequest to a
          device TEE to create a Security Domain for a SP. Such a request
          is signed by TSM where the TSM signer may or may not be the
          same as the SP's TA signer certificate. The resulting SD is
          associated with two identifiers for future management: 
            <list hangIndent="2" style="symbols">
              <t>TSM as the owner. The owner identifier is a registered
              unique TSM ID that is stored in the TSM certificate.</t>
              <t>SP identified by its TA signer certificate as the
              authorization. A TSM can add more than one SP certificates
              to a SD.</t>
            </list></t>
          <t>A Trusted Application that is signed by a matching SP signer
          certificate for a SD is eligible to be installed into that SD.
           The TA installation into a SD by a subsequent InstallTARequest 
           message may be instructed from TSM or a Client Application.
          </t>

          <section anchor="createsdreq" title="CreateSDRequest Message">
            <figure>
              <preamble>The request message for CreateSD has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
   "CreateSDTBSRequest": {
     "ver": "1.0",
     "rid": "<unique request ID>",
     "tid": "<transaction ID>", // this may be from prior message
     "tee": "<TEE routing name from the DSI for the SD's target>",
     "nextdsi": "true | false",
     "dsihash": "<hash of DSI returned in the prior query>",
     "content": ENCRYPTED { // this piece of JSON data will be 
                             // encrypted
           "spid": "<SP ID value>",
        "sdname": "<SD name for the domain to be created>",        
        "spcert": "<BASE64 encoded SP certificate>",
        "tsmid": "<An identifiable attribute of the TSM 
                   certificate>",
        "did": "<SHA256 hash of the TEE cert>"
     }
   }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD creation. The
              encryption key is TSMmk that is encrypted by the target
              TEE's public key. The entire message is signed by the TSM
              private key TSMpriv. A separate TSMmk isn't used in the
              latest specification because JSON encryption will use a
              content encryption key for exactly the same purpose.</t>
              <t hangText="spid -"> A unique id assigned by the TSM for
              its SP. It should be unique within a TSM namespace.</t>
              <t hangText="sdname -"> a name unique to the SP. TSM should
              ensure it is unique for each SP.</t>
              <t hangText="spcert -"> The SP's TA signer certificate is
              included in the request. This certificate will be stored by
              the device TEE and uses it to check against TA
              installation. Only if a TA is signed by a matching spcert
              associated with a SD the TA will be installed into the
              SD.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned
              by a TSM will be associated with a trusted identifier
              defined as an attribute in the signer TSM certificate. TEE
              will be responsible to assign this ID to the SD. The TSM
              certificate attribute for this attribute TSMID must be
              vetted by the TSM signer issuing CA. With this trusted
              identifier, SD query at TEE can be fast upon TSM signer
              verification.</t>
              <t hangText="did -"> 
              The SHA256 hash of the binary encoded device TEE certificate. 
              The encryption key CEK will be encrypted the
              recipient TEE's public key. This hash value in the "did"
              property allows the recipient TEE to check whether it is
              the expected target to receive such a request. If this
              isn't given, an OTrP message for device 2 could be sent
              to device 1. It is optional for TEE to check because the
              successful decryption of the request message with this
              device's TEE private key already proves it is the target.
              This explicit hash value makes the protocol not dependent
              on message encryption method in future.</t>
            </list></t>

            <figure>
              <preamble>Following is the OTrP message template, the full
              request is signed message over the CreateSDTBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
{
    "CreateSDRequest": {
        "payload":"<CreateSDTBSRequest JSON above>",
        "protected":"<integrity-protected header contents>",
        "header":  <non-integrity-protected header contents>,
        "signature":"<signature contents signed by TSM private key>"
    }
}
             ]]></artwork>
            </figure>
            
            <t>TSM signer certificate is included in the "header" property.</t>
               
          </section>

          <section anchor="createsdreqproc" title="Request processing requirements at a TEE">
            <t>Upon receiving a request message CreateSDRequest at a TEE,
            the TEE must validate a request:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>Validate JSON message signing</t>
                  <t>Validate that the request TSM certificate is chained
                  to a trusted CA that the TEE embeds as its trust
                  anchor</t>
                  <t>Compare dsihash with its current state to make sure
                  nothing has changed since this request was sent.</t>
                  <t>Decrypt to get the plaintext of the content: (a)
                  spid, (b) sd name, (c) did </t>                  
                  <t>Check that a SPID is supplied</t>
                  <t>spcert check: check it is a valid certificate
                  (signature and format verification only)</t>
                  <t>Check "did" is the SHA256 hash of its TEEcert BER
                  raw binary data</t>
                  <t>Check whether the requested SD already exists for
                  the SP</t>
                  <t>Check TSMID in the request matches TSM certificate's
                  TSM ID attribute</t>
                </list>
              </t>
              <t>Create action
                <list hangIndent="2" style="symbols">
                  <t>Create a SD for the SP with the given name</t>
                  <t>Assign the TSMID from the TSMCert to this SD</t>
                  <t>Assign the SPID and SPCert to this SD</t>
                  <t>Check whether a TEE SP AIK keypair already exists
                  for the given SP ID</t>
                  <t>Create TEE SP AIK keypair if it doesn't exist for
                  the given SP ID</t>
                  <t>Generate new DSI data if the request asks for
                  updated DSI</t>
                </list>
              </t>
              <t>Construct CreateSDResponse message
                <list hangIndent="2" style="symbols">
                  <t>Create raw content
                    <list hangIndent="2" style="symbols">
                        <t>Operation status</t>
                        <t>"did" or full signer certificate information,
                        </t>
                        <t>TEE SP AIK public key if DSI isn't going to be
                        included</t>
                        <t>Updated DSI data if requested if the request
                        asks for it</t>
                    </list>
                  </t>
                  <t>The response message is encrypted with the
                     same JWE CEK of the request without recreating a
                     new content encryption key.</t>
                  <t>The encrypted message is signed with TEEpriv.
                     The signer information ("did" or TEEcert) is
                     encrypted. </t>
                </list>
              </t>
              <t>Deliver response message. (a) OTrP Agent returns this to
              the app; (b) The app passes this back to TSM</t>
              <t>TSM process. (a) TSM processes the response message; (b)
              TSM can look up signer certificate from device ID "did".</t>
             </list>
            </t>
            
            <t>If a request is illegitimate or signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>
            
          </section>

          <section anchor="createsdresp" title="CreateSDResponse Message">
            <t>The response message for a CreateSDRequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "CreateSDTBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id received from the request>",        
      "sdname": "<SD name for the domain created>",
      "teespaik": "<TEE SP AIK public key, BASE64 encoded>",
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - ">The SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TSM.</t>
              <t hangText="teespaik - ">The newly generated SP AIK public
              key for the given SP. This is an optional value if the
              device has had another domain for the SP that has triggered
              TEE SP AIK keypair for this specific SP.</t>
             </list>
            </t>

            <t>There is possible extreme error case where TEE isn't
            reachable or the TEE final response generation itself fails.
            In this case, TSM should still receive a response from the
            OTrP Agent. OTrP Agent is able to detect such error from TEE.
            In this case, a general error response message should be
            returned, assuming OTrP Agent even doesn't know any content
            and information about the request message.</t>

            <t>In other words, TSM should expect receive a TEE
            successfully signed JSON message, or a general "status"
            message.</t>

            <figure>
              <artwork><![CDATA[
{
  "CreateSDResponse": {
    "payload":"<CreateSDTBSResponse JSON above>",
    "protected": {
       "<BASE64URL of signing algorithm>"
    },
    "signature": "<signature contents signed by TEE device private 
                  key (BASE64URL)>"
  }
}
                        
             ]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>

            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
          </section>

          <section anchor="createsderrors" title="Error Conditions">
            <t> An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_ALREADY_EXIST"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_SPCERT_INVALID"></t>                
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>

<!-- TBD keep here in case we want to restore the full detail again -->
<!--             
                <t hangText="ERR_REQUEST_INVALID -">  This error will
                occur if the TEE meets the following conditions with a
                request message: (1) The request from a TSM has an
                invalid message structure; mandatory information is
                absent in the message. undefined member or structure is
                included.  (2) TEE fails to verify signature of the
                message or fails to decrypt its contents. (3) etc.</t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION -">  This error
                will occur if TEE receives the version of message that
                TEE can't deal with.</t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG -">  This error
                will occur if TEE receives a request message encoded with
                cryptographic algorithms that TEE doesn't support.</t>
                <t hangText="ERR_TEE_UNKNOWN -">  This error will occur
                if the receiver TEE is not supposed to receive the
                request. That will be determined by checking TEE name or
                device id in the request message.</t>
                <t hangText="ERR_SD_ALREADY_EXIST -">  This error will
                occur if SD to be created already exist in the TEE.</t>
                <t hangText="ERR_SPCERT_INVALID -">  If new SP
                certificate for the SD to be updated is not valid, then
                TEE will return this error code.</t>
                <t hangText="ERR_TSM_NOT_TRUSTED -">  Before processing a
                request, TEE needs to make sure whether the sender TSM is
                trustworthy by checking the validity of TSM  certificate
                etc. If TEE finds TSM is not reliable, then it will
                return this error code.</t>
                <t hangText="ERR_DEV_STATE_MISMATCH -">  TEE will return
                this error code if DSI hash value from TSM doesn't match
                with that of device's current DSI.</t>
                <t hangText="ERR_TEE_FAIL -">  TEE fails to respond to a
                TSM request. The OTrP Agent will construct an error
                message in responding the TSM's request. And also if TEE
                fails to process a request because of its internal error,
                it will return this error code.</t>
-->                
              </list>
            </t>
          </section>

        </section> <!-- Create SD -->

        <section anchor="updatesd" title="UpdateSD">
          <t>This TSM initiated command can update a SP's SD that it manages 
          for the following need. (a) Update SP signer certificate; 
          (b) Add SP signer certificate when a SP uses multiple to sign 
          TA binary; (c) Update SP ID.</t>

          <t>The TSM presents the proof of the SD ownership to TEE, and 
          includes related information in its signed message. The entire 
          request is also encrypted for the end-to-end confidentiality.
          </t>

          <section anchor="updatesdreq" title="UpdateSDRequest Message">
            <figure>
              <preamble>The request message for UpdateSD has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
   "UpdateSDTBSRequest": {
     "ver": "1.0",
     "rid": "<unique request ID>",
     "tid": "<transaction ID>", // this may be from prior message
     "tee": "<TEE routing name from the DSI for the SD's target>",
     "nextdsi": "true | false",
     "dsihash": "<hash of DSI returned in the prior query>",
     "content": ENCRYPTED { // this piece of JSON will be encrypted
       "tsmid": "<TSMID associated with this SD>",
       "spid": "<SP ID>",
       "sdname": "<SD name for the domain to be updated>",        
       "changes": {
         "newsdname": "<Change the SD name to this new name>", 
                       // Optional
         "newspid": "<Change SP ID of the domain to this new value>", 
                       // Optional
         "spcert": ["<BASE64 encoded new SP signer cert to be added>"], 
                       // Optional
         "deloldspcert": ["<The SHA256 hex value of an old SP cert 
                    assigned into this SD that should be deleted >"], 
                       // Optional
         "renewteespaik": "true | false"
         }
     }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The 
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned 
              by a TSM will be associated with a trusted identifier 
              defined as an attribute in the signer TSM certificate.</t>
              <t hangText="spid -"> the identifier of the SP whose SD 
              will be updated. This value is still needed because SD name
               is considered unique within a SP only.</t>
              <t hangText="sdname -"> the name of the target SD to be 
              updated.</t>
              <t hangText="changes -"> its content consists of changes 
              that should be updated in the given SD.</t>
              <t hangText="newsdname -"> the new name of the target SD 
              to be assigned if this value is present.</t>
              <t hangText="newspid -"> the new SP ID of the target SD to 
              be assigned if this value is present.</t>
              <t hangText="spcert -"> a new TA signer certificate of this
              SP to be added to the SD if this is present.</t>
              <t hangText="deloldspcert  -"> a SP certificate assigned
              into the SD should be deleted if this is present. The value
              is the SHA256 fingerprint of the old SP certificate.</t>
              <t hangText="renewteespaik -"> the value should be 'true'
              or 'false'. If it is present and the value is 'true', TEE
              should regenerate TEE SP AIK for this SD's owner SP. The newly
              generated TEE SP AIK for the SP must be returned in the
              response message of this request. If there are more than
              one SD for the SP, a new SPID for one of the domain will
              always trigger a new teespaik generation as if a new SP is
              introduced to the TEE.</t>
            </list></t>

            <figure>
              <preamble>Following the OTrP message template, the full
              request is signed message over the UpdateSDTBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
{
  "UpdateSDRequest": {
    "payload":"<UpdateSDTBSRequest JSON above>",
    "protected":"<integrity-protected header contents>",
    "header":  <non-integrity-protected header contents>,
    "signature":"<signature contents signed by TSM private key>"
  }
}
             ]]></artwork>
            </figure>
            
            <t>TSM signer certificate is included in the "header" property.</t>
               
          </section>

          <section anchor="updatesdreqproc" 
            title="Request processing requirements at a TEE">
            <t>Upon receiving a request message UpdateSDRequest at a TEE,
            the TEE must validate a request:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>Validate JSON message signing</t>
                  <t>Validate that the request TSM certificate is chained
                  to a trusted CA that the TEE embeds as its trust
                  anchor. TSM certificate status check is generally not
                  needed anymore in this request. The prior request
                  should have validated the TSM certificate's revocation
                  status</t>
                  <t>Compare dsihash with TEE cached last response
                  DSI data to this TSM</t>
                  <t>Decrypt to get the plaintext of the content</t>                  
                  <t>Check that the target SD name is supplied</t>
                  <t>Check whether the requested SD exists</t>
                  <t>Check that the TSM owns this TSM by verifying
                  TSMID in the SD matches TSM certificate's TSM ID
                  attribute</t>
                  <t>Now the TEE is ready to carry out update listed in
                  the "content" message</t>
                </list>
              </t>
              <t>Update action
                <list hangIndent="2" style="symbols">
                  <t>If "newsdname" is given, replace the SD name for the
                  SD to the new value</t>
                  <t>If "newspid" is given, replace the SP ID assigned to
                  this SD with the given new value</t>
                  <t>If "spcert" is given, add this new SP certificate to
                  the SD.</t>
                  <t>If "deloldspcert" is present in the content, check
                  previously assigned SP certificates to this SD, and
                  delete the one that matches the given certificate hash
                  value.</t>
                    <t>If "renewteespaik" is given and has a value as "true", 
                  generate a new TEE SP AIK keypair,
                  and replace the old one with this.</t>
                  <t>Generate new DSI data if the request asks for
                  updated DSI</t>
                  <t>Now the TEE is ready to construct the response
                  message</t>
                </list>
              </t>
              <t>Construct UpdateSDResponse message
                <list hangIndent="2" style="symbols">
                  <t>Create raw content
                    <list hangIndent="2" style="symbols">
                        <t>Operation status</t>
                        <t>"did" or full signer certificate information,
                        </t>
                        <t>TEE SP AIK public key if DSI isn't going to be
                        included</t>
                        <t>Updated DSI data if requested if the request
                        asks for it</t>
                    </list>
                  </t>
                  <t>The response message is encrypted with the
                     same JWE CEK of the request without recreating a
                     new content encryption key.</t>
                  <t>The encrypted message is signed with TEEpriv.
                     The signer information ("did" or TEEcert) is
                     encrypted. </t>
                </list>
              </t>
              <t>Deliver response message. (a) OTrP Agent returns this to
              the app; (b) The app passes this back to TSM</t>
              <t>TSM process. (a) TSM processes the response message; (b)
              TSM can look up signer certificate from device ID "did".</t>
             </list>
            </t>
            
            <t>If a request is illegitimate or signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>
            
          </section>

          <section anchor="updatesdresp" title="UpdateSDResponse Message">
            <t>The response message for a UpdateSDRequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "UpdateSDTBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",        
      "cert": "<TEE certificate>", // optional 
      "teespaik": "<TEE SP AIK public key, BASE64 encoded>",
      "teespaiktype": "<TEE SP AIK key type: RSA or ECC>",
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - ">The request should have known the
              signer certificate of this device from a prior request.
              This hash value of the device TEE certificate serves as a
              quick identifier only. Full device certificate isn't
              necessary.</t>
              <t hangText="teespaik - ">the newly generated SP AIK public
              key for the given SP if TEE SP AIK for the SP is asked to be
              renewed in the request. This is an optional value if "dsi"
              is included in the response, which will contain all up to
              date TEE SP AIK key pairs.</t>
             </list>
            </t>

            <t>Similar to the template for the creation of the
            encrypted and signed CreateSDResponse, the final
            UpdateSDResponse looks like the following.</t>

            <figure>
              <artwork><![CDATA[
{
  "UpdateSDResponse": {
    "payload":"<UpdateSDTBSResponse JSON above>",
    "protected": {
        "<BASE64URL of signing algorithm>"
    },
    "signature": "<signature contents signed by TEE device private 
                  key (BASE64URL)>"
  }
}
                        
             ]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>

            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
                      
          </section>

          <section anchor="updatesderrors" title="Error Conditions">
            <t> An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_SDNAME_ALREADY_USED"></t>
                <t hangText="ERR_SPCERT_INVALID"></t>                
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>

        </section> <!-- updatesd -->

        <section anchor="deletesd" title="DeleteSD">
          <t>A TSM sends a DeleteSDRequest message to TEE to delete a
          specified SD that it owns. A SD can be deleted only if there is
          no TA associated with this SD in the device. The request
          message can contain a flag to instruct TEE to delete all
          related TAs in a SD and then delete the SD.</t>

          <t>The target TEE will operate with the following logic.
            <list hangIndent="2" style="numbers">
              <t>Lookup given SD specified in the request message</t>
              <t>Check that the TSM owns the SD</t>
              <t>Check that the device state hasn't changed since the
              last operation</t>
              <t>Check whether there are TAs in this SD</t>
              <t>If TA exists in a SD, check whether the request
              instructs whether TA should be deleted. If the request
              instructs TEE to delete TAs, delete all TAs in this SD. If
              the request doesn't instruct the TEE to delete TAs, return
              an error "ERR_SD_NOT_EMPTY".</t>
              <t>Delete SD</t>
              <t>If this is the last SD of this SP, delete TEE SP AIK
              key</t>
            </list>
          </t>

          <section anchor="deletesdreq" title="DeleteSDRequest Message">
            <figure>
              <preamble>The request message for DeleteSD has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
   "DeleteSDTBSRequest": {
     "ver": "1.0",
     "rid": "<unique request ID>",
     "tid": "<transaction ID>", // this may be from prior message
     "tee": "<TEE routing name from the DSI for the SD's target>",
     "nextdsi": "true | false",
     "dsihash": "<hash of DSI returned in the prior query>",
     "content": ENCRYPTED { // this piece of JSON will be encrypted
       "tsmid": "<TSMID associated with this SD>",
       "sdname": "<SD name for the domain to be updated>",        
       "deleteta": "true | false"
     }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The 
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned 
              by a TSM will be associated with a trusted identifier 
              defined as an attribute in the signer TSM certificate.</t>
              <t hangText="sdname -"> the name of the target SD to be 
              updated.</t>
              <t hangText="deleteta -"> the value should be 'true' or 'false'.
              If it is present and the value is 'true', TEE should delete all
              TAs associated with the SD in the device.</t>
            </list></t>

            <figure>
              <preamble>Following the OTrP message template, the full
              request is signed message over the DeleteSDTBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
{
    "DeleteSDRequest": {
        "payload":"<DeleteSDTBSRequest JSON above>",
        "protected":"<integrity-protected header contents>",
        "header":  <non-integrity-protected header contents>,
        "signature":"<signature contents signed by TSM private key>"
    }
}
             ]]></artwork>
            </figure>
            
            <t>TSM signer certificate is included in the "header" property.</t>
               
          </section>

          <section anchor="deletesdreqproc" 
            title="Request processing requirements at a TEE">
            <t>Upon receiving a request message DeleteSDRequest at a TEE,
            the TEE must validate a request:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>Validate JSON message signing</t>
                  <t>Validate that the request TSM certificate is chained
                  to a trusted CA that the TEE embeds as its trust
                  anchor. TSM certificate status check is generally not
                  needed anymore in this request. The prior request
                  should have validated the TSM certificate's revocation
                  status</t>
                  <t>Compare dsihash with TEE cached last response
                  DSI data to this TSM</t>
                  <t>Decrypt to get the plaintext of the content</t>                  
                  <t>Check that the target SD name is supplied</t>
                  <t>Check whether the requested SD exists</t>
                  <t>Check that the TSM owns this TSM by verifying
                  TSMID in the SD matches TSM certificate's TSM ID
                  attribute</t>
                  <t>Now the TEE is ready to carry out update listed in
                  the "content" message</t>
                </list>
              </t>
              <t>Deletion action
                <list hangIndent="2" style="symbols">
                  <t>Check TA existence in this SD</t>
                  <t>If "deleteta" is "true", delete all TAs in this SD.
                  If the value of "deleteta" is "false" and some TA exists,
                  return an error "ERR_SD_NOT_EMPTY"</t>
                  <t>Delete the SD</t>
                  <t>Delete TEE SP AIK key pair if this SD is the last
                  one for the SP</t>
                  <t>Now the TEE is ready to construct the response
                  message</t>
                </list>
              </t>
              <t>Construct DeleteSDResponse message
                <list hangIndent="2" style="symbols">
                  <t>Create response content
                    <list hangIndent="2" style="symbols">
                        <t>Operation status</t>
                        <t>"did" or full signer certificate information,
                        </t>
                        <t>Updated DSI data if requested if the request
                        asks for it</t>
                    </list>
                  </t>
                  <t>The response message is encrypted with the
                     same JWE CEK of the request without recreating a
                     new content encryption key.</t>
                  <t>The encrypted message is signed with TEEpriv.
                     The signer information ("did" or TEEcert) is
                     encrypted. </t>
                </list>
              </t>
              <t>Deliver response message. (a) OTrP Agent returns this to
              the app; (b) The app passes this back to TSM</t>
              <t>TSM process. (a) TSM processes the response message; (b)
              TSM can look up signer certificate from device ID "did".</t>
             </list>
            </t>
            
            <t>If a request is illegitimate or signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>
            
          </section>

          <section anchor="deletesdresp" title="DeleteSDResponse Message">
            <t>The response message for a DeleteSDRequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "DeleteSDTBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",        
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - ">The request should have known the
              signer certificate of this device from a prior request.
              This hash value of the device TEE certificate serves as a
              quick identifier only. Full device certificate isn't
              necessary.</t>
             </list>
            </t>

            <t>The final DeleteSDResponse looks like the following.</t>

            <figure>
              <artwork><![CDATA[
{
  "DeleteSDResponse": {
    "payload":"<DeleteSDTBSResponse JSON above>",
    "protected": {
        "<BASE64URL of signing algorithm>"
    },
    "signature": "<signature contents signed by TEE device 
      private key (BASE64URL)>"
  }
}]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>
            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
          </section>

          <section anchor="deletesderrors" title="Error Conditions">
            <t> An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_EMPTY"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- delete sd -->
      </section>

      <section anchor="tamgmt" title="Trusted Application Management">      
        <t>This protocol doesn't introduce a TA container concept. All
        the TA authorization and management will be up to TEE
        implementation.
        </t>
        
        <t>The following three TA management commands will be supported.
            <list hangIndent="2" style="symbols">
              <t>InstallTA - provision a TA by TSM</t>
              <t>UpdateTA - update a TA by TSM</t>
              <t>DeleteTA - remove TA registration information with a SD,
              remove TA binary from TEE, remove all TA related data in
              TEE</t>
            </list>
        </t>

        <section anchor="installta" title="InstallTA">
          <t>TA binary data can be from two sources:
            <list hangIndent="2" style="numbers">
              <t>TSM supplies the signed TA binary</t>
              <t>Client Application supplies the TA binary</t>
            </list>
          </t>
          
          <t>This specification considers only the first case where TSM
          supplies TA binary. When such a request is received by TEE, a
          SD is already created and is ready to take TA
          installation.</t>

          <t>A TSM sends the following information in message
          InstallTARequest to a target TEE:
            <list hangIndent="2" style="symbols">
              <t>The target SD information: SP ID and SD name</t>
              <t>Encrypted TA binary data. TA data is encrypted with TEE
              SP AIK.</t>
              <t>TA metadata. It is optional to include SP signer certificate
              for the SD to add if the SP has changed signer since the SD
              was created.</t>
            </list>
          </t>

          <t>TEE processes command given by TSM to install TA into a SP's
          SD. It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>TEE validates TSM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Lookup SD with SD name</t>
                  <t>Checks that the TSM owns the SD</t>
                  <t>Checks DSI hash matches that the device state hasn't
                  changed</t>                  
                </list>
              </t>
              <t>TA validation
                <list hangIndent="2" style="symbols">
                  <t>Decrypt to get TA binary and any personalization
                  data with "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>TA signer is either the newly given SP certificate
                  or the one in SD. The TA signing method is specific to
                  TEE. This specification doesn't define how a TA should
                  be signed.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD.</t>
                </list>
              </t>
              <t>TA installation
                <list hangIndent="2" style="symbols">
                  <t>TEE re-encrypts TA binary and its personalization
                  data with its own method</t>
                  <t>TEE enrolls and stores the TA onto TEE secure
                  storage area.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing a
              encrypted status information for the requesting TSM.</t>
            </list>
          </t>

          <section anchor="installtareq" title="InstallTARequest Message">
            <figure>
              <preamble>The request message for InstallTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "InstallTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": "true | false",
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED { 
      "tsmid": "<TSM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to install the TA>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<A 256-bit symmetric key encrypted by TEEspaik public 
              key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphertadata": "<BASE64 encoded encrypted TA binary data>",
      "cipherpdata": "<BASE64 encoded encrypted TA personalization 
                      data>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The 
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned 
              by a TSM will be associated with a trusted identifier 
              defined as an attribute in the signer TSM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA should be installed</t>
              <t hangText="spcert -"> an optional field to specify SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA should be installed.</t>
              <t hangText="taid -"> the identifier of the TA application
              to be installed</t>
              <t hangText="encrypted_ta -"> the message portion contains
              encrypted TA binary data and personalization data. The TA
              data encryption key is placed in "key", which is encrypted
              by the recipient's public key. The TA data encryption uses
              symmetric key based encryption such as AESCBC.</t>
            </list></t>

            <figure>
              <preamble>Following the OTrP message template, the full
              request is signed message over the InstallTATBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
{
    "InstallTARequest": {
        "payload":"<InstallTATBSRequest JSON above>",
        "protected":"<integrity-protected header contents>",
        "header":  <non-integrity-protected header contents>,
        "signature":"<signature contents signed by TSM private key>"
    }
}
             ]]></artwork>
            </figure>            
          </section>

          <section anchor="installtaresp" title="InstallTAResponse Message">
            <t>The response message for a InstallTARequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "InstallTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",        
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TSM.</t>
             </list>
            </t>

            <t>The final message InstallTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "InstallTAResponse": {
        "payload":"<InstallTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device 
          private key (BASE64URL)>"
    }
}
                        
             ]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>
            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
          </section>

          <section anchor="installtaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>                
                <t hangText="ERR_TA_ALREADY_INSTALLED"></t>                
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TEE_RESOURCE_FULL"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- install TA -->

        <section anchor="updateta" title="UpdateTA">
          <t>This TSM initiated command can update TA and its data in a
          SP's SD that it manages for the following purposes.
            <list hangIndent="2" style="numbers">
              <t>Update TA binary</t>
              <t>Update TA's personalization data</t>
            </list>
          </t>
          
          <t>The TSM presents the proof of the SD ownership to TEE, and
          includes related information in its signed message. The entire
          request is also encrypted for the end-to-end
          confidentiality.</t>

          <t>TEE processes command given by TSM to update TA of a SP SD.
          It does the following:
            <list hangIndent="2" style="symbols">
              <t>Validation
                <list hangIndent="2" style="symbols">
                  <t>TEE validates TSM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Lookup SD with SD name</t>
                  <t>Checks that the TSM owns the SD</t>
                  <t>Checks DSI hash matches that the device state hasn't
                  changed</t>                  
                </list>
              </t>
              <t>TA validation
                <list hangIndent="2" style="symbols">
                  <t>Both TA binary and personalization data are
                  optional, but at least one of them shall be present in
                  the message</t>
                  <t>Decrypt to get TA binary and any personalization
                  data with "TEE SP AIK private key"</t>
                  <t>Check that SP ID is the one that is registered with
                  the SP SD</t>
                  <t>TA signer is either the newly given SP certificate
                  or the one in SD. The TA signing method is specific to
                  TEE. This specification doesn't define how a TA should
                  be signed.</t>
                  <t>If a TA signer is given in the request, add this
                  signer into the SD</t>
                </list>
              </t>
              <t>TA update
                <list hangIndent="2" style="symbols">
                  <t>TEE re-encrypts TA binary and its personalization
                  data with its own method</t>
                  <t>TEE replaces the existing TA binary and its
                  personalization data with the new binary and data.</t>
                </list>
              </t>
              <t>Construct a response message. This involves signing a
              encrypted status information for the requesting TSM.</t>
            </list>
          </t>

          <section anchor="updatetareq" title="UpdateTARequest Message">
            <figure>
              <preamble>The request message for UpdateTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "UpdateTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": "true | false",
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED { 
      "tsmid": "<TSM ID previously assigned to the SD>",
      "spid": "<SPID value>",
      "sdname": "<SD name for the domain to be created>",
      "spcert": "<BASE64 encoded SP certificate >", // optional
      "taid": "<TA identifier>"
    },
    "encrypted_ta": {
      "key": "<A 256-bit symmetric key encrypted by TEEspaik public 
              key>",
      "iv": "<hex of 16 random bytes>",
      "alg": "<encryption algoritm. AESCBC by default.",
      "ciphernewtadata": "<Change existing TA binary to this new TA
          binary data(BASE64 encoded and encrypted)>",
      "ciphernewpdata": "<Change the existing data to this new TA
          personalization data(BASE64 encoded and encrypted)>" 
          // optional
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The 
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned 
              by a TSM will be associated with a trusted identifier 
              defined as an attribute in the signer TSM certificate.</t>
              <t hangText="spid -"> SP identifier of the TA owner SP</t>
              <t hangText="spcert -"> an optional field to specify SP
              certificate that signed the TA. This is sent if the SP has
              a new certificate that hasn't been previously registered
              with the target SD where the TA should be installed.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA should be updated</t>
              <t hangText="taid -"> an identifier for the TA application
              to be updated</t>
              <t hangText="encrypted_ta -"> the message portion contains
              new encrypted TA binary data and personalization data.</t>
            </list></t>

            <figure>
              <preamble>Following the OTrP message template, the full
              request is signed message over the UpdateTATBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
              
              
{
    "UpdateTARequest": {
        "payload":"<UpdateTATBSRequest JSON above>",
        "protected":"<integrity-protected header contents>",
        "header":  <non-integrity-protected header contents>,
        "signature":"<signature contents signed by TSM private key>"
    }
}
             ]]></artwork>
            </figure>            
          </section>

          <section anchor="updatetaresp" title="UpdateTAResponse Message">
            <t>The response message for a UpdateTARequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "UpdateTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",        
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TSM.</t>
             </list>
            </t>

            <t>The final message UpdateTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "UpdateTAResponse": {
        "payload":"<UpdateTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device 
          private key (BASE64URL)>"
    }
}
                        
             ]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>
            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
          </section>

          <section anchor="updatetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_INVALID"></t>                
                <t hangText="ERR_TA_NOT_FOUND"></t>                
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- update TA -->

        <section anchor="deleteta" title="DeleteTA">
          <t>This operation defines OTrP messages that allow a TSM
          instruct a TEE to delete a TA for a SP in a given SD. A TEE
          will delete a TA from a SD and also TA data in the TEE.
          A Client Application cannot directly access TEE or OTrP
          Agent to delete a TA.
          </t>
          
          <section anchor="deletetareq" title="DeleteTARequest Message">
            <figure>
              <preamble>The request message for DeleteTA has the
              following JSON format.</preamble>
              <artwork><![CDATA[
{
  "DeleteTATBSRequest": {
    "ver": "1.0",
    "rid": "<unique request ID>",
    "tid": "<transaction ID>",
    "tee": "<TEE routing name from the DSI for the SD's target>",
    "nextdsi": "true | false",
    "dsihash": "<hash of DSI returned in the prior query>",
    "content": ENCRYPTED { 
      "tsmid": "<TSM ID previously assigned to the SD>",
      "sdname": "<SD name of the TA>",
      "taid": "<the identifier of the TA to be deleted from the 
               specified SD>"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>In the message, <list hangIndent="2" style="hanging">
              <t hangText="rid -"> A unique value to identify this
              request</t>
              <t hangText="tid -"> A unique value to identify this
              transaction. It can have the same value for the tid in the
              preceding GetDeviceStateRequest.</t>
              <t hangText="tee -"> TEE ID returned from the previous
              response GetDeviceStateResponse </t>
              <t hangText="nextdsi -"> Indicates whether the up to date
              Device State Information (DSI) should be returned in the
              response to this request.</t>
              <t hangText="dsihash -"> The BASE64 encoded SHA256 hash
              value of the DSI data returned in the prior TSM operation
              with this target TEE. This value is always included such
              that a receiving TEE can check whether the device state has
              changed since its last query. It helps enforce SD update
              order in the right sequence without accidently overwrite an
              update that was done simultaneously.</t>
              <t hangText="content -"> The "content" is a JSON encrypted
              message that includes actual input for the SD update. The 
              standard JSON content encryption key (CEK) is used, and the
              CEK is encrypted by the target TEE's public key.</t>
              <t hangText="tsmid -"> SD owner claim by TSM - A SD owned 
              by a TSM will be associated with a trusted identifier 
              defined as an attribute in the signer TSM certificate.</t>
              <t hangText="sdname -"> the name of the target SD where the
              TA is installed</t>
              <t hangText="taid -"> an identifier for the TA application
              to be deleted</t>
            </list></t>

            <figure>
              <preamble>Following the OTrP message template, the full
              request is signed message over the DeleteTATBSRequest as
              follows.
              </preamble>

              <artwork><![CDATA[
              
              
{
    "DeleteTARequest": {
        "payload":"<DeleteTATBSRequest JSON above>",
        "protected":"<integrity-protected header contents>",
        "header":  <non-integrity-protected header contents>,
        "signature":"<signature contents signed by TSM 
            private key>"
    }
}
             ]]></artwork>
            </figure>            
          </section>

          <section anchor="deletetareqproc" 
            title="Request processing requirements at a TEE">
          
            <t>TEE processes command given by TSM to delete a TA of a SP
            SD. It does the following:
             <list hangIndent="2" style="numbers">
              <t>Validate the JSON request message
                <list hangIndent="2" style="symbols">
                  <t>TEE validates TSM message authenticity</t>
                  <t>Decrypt to get request content</t>
                  <t>Lookup the SD and the TA with the given SD name and
                  TA ID</t>
                  <t>Checks that the TSM owns the SD, and TA is installed
                  in the SD</t>
                  <t>Checks DSI hash matches that the device state hasn't
                  changed</t>
                </list>
              </t>                
              <t>Deletion action
                <list hangIndent="2" style="symbols">
                  <t>If all the above validation points pass, the TEE
                  deletes the TA from the SD</t>
                  <t>The TEE may also delete all personalization data for
                  the TA</t>
                </list>
              </t>
              <t>Construct DeleteTAResponse message.</t>
             </list>
            </t>
            
            <t>If a request is illegitimate or signature doesn't pass, a
            "status" property in the response will indicate the error
            code and cause.
            </t>
            
          </section>

          <section anchor="deletetaresp" title="DeleteTAResponse Message">
            <t>The response message for a DeleteTARequest contains the
            following content.</t>
            
            <figure>
              <artwork><![CDATA[
{  
  "DeleteTATBSResponse": {
    "ver": "1.0",
    "status": "<operation result>",
    "rid": "<the request ID received>",
    "tid": "<the transaction ID received>",
    "content": ENCRYPTED {
      "reason":"<failure reason detail>", // optional
      "did": "<the device id hash>",        
      "dsi": "<Updated TEE state, including all SD owned by 
        this TSM>"
    }
  }
}                         
             ]]></artwork>
            </figure>

            <t>In the response message, the following fields MUST be supplied.
             <list hangIndent="2" style="hanging">
              <t hangText="did - "> the SHA256 hash of the device TEE
              certificate. This shows the device ID explicitly to the
              receiving TSM.</t>
             </list>
            </t>

            <t>The final message DeleteTAResponse looks like the
            following.</t>

            <figure>
              <artwork><![CDATA[
{
    "DeleteTAResponse": {
        "payload":"<DeleteTATBSResponse JSON above>",
        "protected": {
            "<BASE64URL of signing algorithm>"
        },
        "signature": "<signature contents signed by TEE device 
            private key (BASE64URL)>"
    }
}
                        
             ]]></artwork>
            </figure>  
            
            <t>A response message type "status" will be returned when TEE
            totally fails to respond. OTrP Agent is responsible to create
            this message.</t>

            <figure>
              <artwork><![CDATA[
{
  "status": {
     "result": "fail",
     "error-code": "ERR_TEE_UNKNOWN",
     "error-message": "TEE fails to respond"
  }
}
             ]]></artwork>
            </figure>
<!-- TBD : we have to unify error message generated from OTrP Agent -->
<!-- Following is the error message format described in Section 9.
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
-->                       
          </section>

          <section anchor="deletetaerrors" title="Error Conditions">
            <t>An error may occur if a request isn't valid or the TEE
            runs into some error. The list of possible errors are the
            following. Refer to section <xref target="errorcodelist">
            Error Code List</xref> for detail causes and actions.
            
              <list hangIndent="2" style="hanging">
                <t hangText="ERR_REQUEST_INVALID"></t>
                <t hangText="ERR_UNSUPPORTED_MSG_VERSION"></t>
                <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG"></t>
                <t hangText="ERR_DEV_STATE_MISMATCH"></t>
                <t hangText="ERR_SD_NOT_FOUND"></t>
                <t hangText="ERR_TA_NOT_FOUND"></t>                
                <t hangText="ERR_TEE_FAIL"></t>
                <t hangText="ERR_TEE_UNKNOWN"></t>
                <t hangText="ERR_TSM_NOT_AUTHORIZED"></t>                
                <t hangText="ERR_TSM_NOT_TRUSTED"></t>
              </list>
            </t>
          </section>
        </section> <!-- delete TA -->
        
      </section>

    </section>

    <section anchor="tsmuse" title="Response Messages a TSM May Expect">
      <t>A TSM expects some feedback from a remote device when a request
        message is delivered to a device. The following three types of
        responses
        SHOULD be supplied.
      </t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 1: ">Expect a valid TEE generated 
              response message</t>
      <t>A valid TEE signed response may contain errors detected by TEE, e.g.
        TSM is trusted but TSM supplied data is missing, for example, SP ID
        doesn't exist. TEE MUST be able to sign and encrypt.
      </t>
      <t>If TEE isn't able to sign a response, TEE should returns an error to
        OTrP Agent without giving any other internal information. OTrP Agent
        will be generating the response.
      </t>
      </list></t>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 2: ">
              OTrP Agent generated error message when TEE fails. OTrP 
              Agent errors will be defined in this document.</t>
              <t>A Type 2 message has the following format.</t>
      </list></t>

      <figure>
        <artwork><![CDATA[
      {
        "OTrPAgentError": {
            "ver": "1.0",
            "rid": "",
            "tid": "",
            "errcode": "ERR_TEE_FAIL | ERR_TEE_BUSY"
        }
      }
           ]]></artwork>
      </figure>

      <t><list hangIndent="4" style="hanging">
              <t hangText="Type 3: ">
        OTrP Agent itself isn't reachable or fails. A Client Application is
        responsible to handle error and response TSM in its own way. This is
        out of scope for this specification.</t>
      </list></t>

    </section>

    <section anchor="basicprofile" title="Basic Protocol Profile">
      <t>This section describes a baseline for interoperability among
      the protocol entities, mainly, the TSM and TEE.</t>

      <t>A TEE MUST support RSA algorithms. It is optional to support
      ECC algorithms. A TSM should use a RSA certificate for TSM message
      signing. It may use an ECC certificate if it detects that the TEE
      supports ECC. </t>
    
      <t>A TSM MUST support both RSA 2048-bit algorithm and ECC P-256
      algorithms. With this, a TEE and TFW certificate can be either RSA
      or ECC type. </t>

      <t>JSON signing algorithms
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1 with SHA256 signing : "RS256"</t>
          <t>ECDSA with SHA256 signing : "ES256"</t>
        </list>
      </t>

      <t>JSON asymmetric encryption algorithms (describes key-exchange
      or key-agreement algorithm for sharing symmetric key with TEE):
        <list hangIndent="2" style="symbols">
          <t>RSA PKCS#1  : "RSA1_5"</t>
          <t>ECDH using TEE ECC P-256 key and ephemeral ECC key 
             generated by TSM : "ECDH-ES+A128W"</t>
        </list>
      </t>
    
      <t>JSON symmetric encryption algorithms (describes symmetric
      algorithm for encrypting body of data, using symmetric key
      transferred to TEE using asymmetric encryption):
        <list hangIndent="2" style="symbols">
          <t>Authenticated encryption AES 128 CBC with SHA256 : 
             {"enc":"A128CBC-HS256"}</t>
        </list>
      </t>
    </section>

    <section anchor="impl" title="Attestation Implementation Consideration">
      <!-- NOTE: this section could be moved to Appendix in RFC -->
      <t>
        It is important to know that the state of a device is appropriate
        before
        trusting that a device is what it says it is. The attestation
        scheme
        for
        OTrP must also be able to cope with different TEEs, those that
        are OTrP
        compliant and those that use another mechanism. In the initial
        version,
        only one active TEE is assumed.
      </t>
      <t>
        It is out of scope about how TSM and device implement the trust
        hierarchy
        verification. However, it is helpful to understand what each
        system
        provider should do in order to properly implement OTrP trust
        hierarchy.
      </t>
      <t>
        In this section, we provide some implementation reference
        consideration.
      </t>

      <section anchor="secureboot" title="OTrP Secure Boot Module">
        <section anchor="attestsigner" title="Attestation signer">
          <t>
            It is proposed that attestation for OTrP is based on the SBM
            secure boot layer, and that further attestation is not
            performed within the TEE itself during security domain
            operations. The rationale is that the device boot process
            will be defined to start with a secure boot approach that,
            using eFuse, only releases attestation signing capabilities
            into the SBM once a secure boot has been established. In this
            way the release of the attestation signer can be considered
            the first "platform configuration metric", using TCG
            terminology.
          </t>
        </section>

        <section anchor="sbmreq" title="SBM initial requirements">
          <t>
            <list counter="reqs" hangIndent="4" style="format R%d">
              <t>SBM must be possible to load securely into the secure boot
                flow
              </t>
              <t>SBM must allow a public / private key pair to be generated
                during
                device manufacture
              </t>
              <t>The public key and certificate must be possible to store
                securely
                from tamper
              </t>
              <t>The private key must be possible to store encrypted at rest
              </t>
              <t>The private key must only be visible to the SBM when it is
                decrypted
              </t>
              <t>The SBM must be able to read a list of root and
              intermediate certificates that it can use to check
              certificate chains with. The list must be stored such that
              it cannot be tampered with
              </t>
              <t>Possible need to allow a TEE to access its unique TEE
              specific private key
              </t>
            </list>
          </t>
        </section>
      </section>

      <section anchor="teeload" title="TEE Loading">
        <t>During boot SBM is required to start all of the ROOT TEEs. Before
        loading them the SBM must first determine whether the code sign
        signature of the TEE is valid. If TEE integrity is confirmed it may be
        started. The SBM must then be able to receive the identity certificate
        from the TEE (if that TEE is OTrP compliant). The identity certificate
        and keys will need to be baked into the TEE image, and therefore also
        covered by the code signer hash during the manufacture process. The
        private key for the identity certificate must be securely protected.
        The private key for a TEE identity must never be released no matter how
        the public key and certificate are released to the SBM.
        </t>
        <t>Once the SBM has successfully booted a TEE and retrieved the
        identity certificate it will commit this to the platform configuration
        register (PCR) set, for later use during attestation. As a minimum the
        following data must be committed to the PCR for each TEE:
        </t>
        <t>
          <list style="numbers">
            <t>Public key and certificate for the TEE</t>
            <t>TEE reference that can be used later by a TSM to identify this
              TEE
            </t>
          </list>
        </t>
      </section>

      <section anchor="attest" title="Attestation Hierarchy">
        <t>The attestation hierarchy and seed required for TSM protocol
        operation must be built into the device at manufacture. Additional TEEs
        can be added post manufacture using the scheme proposed however it is
        outside of the current scope of this document to detail that.
        </t>
        <t>It should be noted that the attestation scheme described is based on
        signatures. The only encryption that takes place is with eFuse to
        release the SBM signing key and later during protocol lifecycle
        management interchange with the TSM.
        </t>

        <section title="Attestation hierarchy establishment: manufacture">
          <t>
            During manufacture the following steps are required:
          </t>
          <t>
            <list style="numbers">
              <t>Device specific TFW key pair and certificate burnt into
                device,
                encrypted by eFuse. This key pair will be used for
                signing operations
                performed by SBM.
              </t>
              <t>TEE images are loaded and include a TEE instance specific
                key
                pair
                and certificate. The key pair and certificate are included
                in the
                image and covered by the code signing hash.
              </t>
              <t>The process for TEE images is repeated for any subordinate
                TEEs
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation hierarchy establishment: device boot">
          <t>During device boot the following steps are required:</t>
          <t>
            <list style="numbers">
              <t>Secure boot releases TFW private key by decrypting with
                eFuse
              </t>
              <t>SBM verifies the code-signing signature of the active TEE
                 and places its TEE public key into a signing buffer, along with
                 their reference for later access. For non-OTrP TEE, the SBM
                 leaves the TEE public key field blank.
              </t>
              <t>SBM signs the signing buffer with TFW private key</t>
              <t>Each active TEE performs the same operation as SBM, building
                up
                their own signed buffer containing subordinate TEE
                information.
              </t>
            </list>
          </t>
        </section>

        <section title="Attestation hierarchy establishment: TSM">
          <t>Before a TSM can begin operation in the marketplace it must
            obtain a TSM key pair and certificate (TSMpub, TSMpriv) from a CA 
            that is registered in the trust store of the TEE. In this way, the
            TEE can check the intermediate and root CA and verify that it 
            trusts this TSM to perform operations on the TEE.
          </t>
        </section>
      </section>
    </section>
    
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We thank Alin Mutu for his contribution to many discussion that helped 
      to design the trust flow mechanisms, and the creation of the flow diagrams. 
      We also thank the following people (by alphabetical order) for their input 
      and review: Sangsu Baek, Marc Canel, Roger Casals, Rob Coombs, Lubna Dajani, 
      Richard Parris, and Pengfei Zhao.
      </t>
    </section>

    <!-- Possibly a 'Contributors' section ... -->
    <section anchor="Contributors" title="Contributors">
        <figure>
          <artwork><![CDATA[
Brian Witten
Symantec
900 Corporate Pointe
Culver City, CA 90230
USA

Email: brian_witten@symantec.com
         ]]></artwork>
        </figure>

        <figure>
          <artwork><![CDATA[
Tyler Kim
Solacia
5F, Daerung Post Tower 2, 306 Digital-ro
Seoul 152-790
Korea

Email: tkkim@sola-cia.com 
         ]]></artwork>
        </figure>
        
      <!--
      <contributor fullname="Brian Witten" initials="B." surname="Witten">
        <organization>Symantec</organization>
        <address>
          <postal>
            <street>900 Corporate Pointe</street>
            <city>Culver City</city>
            <region>CA</region>
            <code>90230</code>
            <country>USA</country>
          </postal>
          <email>brian_witten@symantec.com</email>
        </address>
      </contributor>-->  
    </section>
    
    <section anchor="IANA" title="IANA Considerations">
      <t>The error code listed in the next section will be registered.</t>

      <section anchor="errorcodelist" title="Error Code List">
        <t>This section lists error codes that could be reported by
        a TA or TEE in a device in responding a TSM request.
          <list hangIndent="2" style="hanging">
            <t hangText="ERR_DEV_STATE_MISMATCH -"> TEE will return
            this error code if DSI hash value from TSM doesn't match
            with that of device's current DSI.</t>

            <t hangText="ERR_SD_ALREADY_EXIST -">  This error will
            occur if SD to be created already exist in the TEE.</t>

            <t hangText="ERR_SD_NOT_EMPTY -"> This is reported if a 
            target SD isn't empty.</t>

            <t hangText="ERR_SDNAME_ALREADY_USED">TEE will return this
            error code if new SD name already exists in the namespace of
            TSM in the TEE.</t>          
        
            <t hangText="ERR_REQUEST_INVALID -"> This error will
            occur if the TEE meets the following conditions with a
            request message: (1) The request from a TSM has an
            invalid message structure; mandatory information is
            absent in the message. undefined member or structure is
            included.  (2) TEE fails to verify signature of the
            message or fails to decrypt its contents. (3) etc.</t>

            <t hangText="ERR_SPCERT_INVALID -">  If new SP
            certificate for the SD to be updated is not valid, then
            TEE will return this error code.</t>

            <t hangText="ERR_TA_ALREADY_INSTALLED -"> while installing TA,
            TEE will return this error if the TA already has been installed
            in the SD.</t>

            <t hangText="ERR_TA_INVALID -"> This error will occur when TEE
            meets any of following conditions while checking validity of
            TA: (1) TA binary has a format that TEE can't recognize. (2)
            TEE fails to decrypt the encoding of TA binary and
            personalization data. (3) If SP isn't registered with the SP SD
            where TA will be installed. (4) etc.</t>

            <t hangText="ERR_TA_NOT_FOUND -"> This error will occurs when
            target TA doesn't exist in the SD.</t>

            <t hangText="ERR_TEE_BUSY -"> The device TEE is busy. The
            request should be generally sent later to retry.</t>
                    
            <t hangText="ERR_TEE_FAIL -"> TEE fails to respond to a
            TSM request. The OTrP Agent will construct an error
            message in responding the TSM's request. And also if TEE
            fails to process a request because of its internal error,
            it will return this error code.</t>
            
            <t hangText="ERR_TEE_RESOURCE_FULL -"> This error is reported
            when a device resource isn't available anymore such as
            storage space is full.</t>

            <t hangText="ERR_TEE_UNKNOWN -">  This error will occur
            if the receiver TEE is not supposed to receive the
            request. That will be determined by checking TEE name or
            device id in the request message.</t>

            <t hangText="ERR_TFW_NOT_TRUSTED -"> TEE may concern the
            underlying device firmware is trustworthy. If TEE determines
            TFW is not trustworthy, then this error will occur.</t>

            <t hangText="ERR_TSM_NOT_TRUSTED -">  Before processing a
            request, TEE needs to make sure whether the sender TSM is
            trustworthy by checking the validity of TSM  certificate
            etc. If TEE finds TSM is not reliable, then it will
            return this error code.</t>
                    
            <t hangText="ERR_UNSUPPORTED_CRYPTO_ALG -">  This error
            will occur if TEE receives a request message encoded with
            cryptographic algorithms that TEE doesn't support.</t>

            <t hangText="ERR_UNSUPPORTED_MSG_VERSION -">  This error
            will occur if TEE receives the version of message that
            TEE can't deal with.</t>
          
          </list>
        </t>      
      </section>
      
    </section>

    <section anchor="security" title="Security Consideration">
      <section title="Cryptographic Strength">
        <t>The strength of the cryptographic algorithms, using the measure of 
           'bits of security' defined in NIST SP800-57 allowed for the OTrP 
            protocol is:</t>
        <t><list style="symbols">
         <t>At a minimum, 112 bits of security. The limiting factor for this is
            the RSA-2048 algorithm, which is indicated as providing 112 bits of symmetric key strength in
            SP800-57. It is important that RSA is supported in order to enhance
            the interoperability of the protocol.</t>
        <t>The option exists to choose algorithms providing 128 bits of 
           security. This requires using TEE devices that support ECC P256.
        </t>
        </list>The available algorithms and key sizes specified in this document are based on industry standards.
          Over time the recommended or allowed cryptographic algorithms may 
          change. It is important that the OTrP protocol allows for crypto-agility.
        </t>
      </section>

      <section title="Message Security">
        <t>OTrP messages between the TSM and TEE are protected by message 
        security using JWS and JWE. The 'Basic protocol profile' section of 
        this document describes the algorithms used for this. All OTrP TEE 
        devices and OTrP TSMs must meet the requirements of the basic profile. 
        In the future additional 'profiles' can be added.</t>
        
        <t>PKI is used to ensure that the TEE will only communicate with a
        trusted TSM, and to ensure that the TSM will only communicate with a
        trusted TEE.</t>
      </section>
    
      <section title="TEE Attestation">
        <t>It is important that the TSM can trust that it is talking to a
        trusted TEE. This is achieved through attestation. The TEE has a private
        key and certificate built into it at manufacture, which is used to sign
        data supplied by the TSM. This allows the TSM to verify that the TEE is
        trusted. </t>

        <t>It is also important that the TFW (trusted firmware) can be checked.
        The TFW has a private key and certificate built into it at manufacturer,
        which allows the TEE to check that that the TFW is trusted. </t>

        <t>The GetDeviceState message therefore allows the TSM to check that it
        trusts the TEE, and the TEE at this point will check whether it trusts
        the TFW. </t>
      </section>
      
      <section title="TA Protection">
        <t>
          TA will be delivered in an encrypted form. This encryption is an
          additional layer within the message encryption described in the 
          'Basic protocol profile' section of this document. The TA binary 
          is encrypted for each target device with the device's TEE SP AIK 
          public key. A TSM may do this encryption or provides the TEE SP AIK 
          public key to a SP such that the SP encrypts the encrypted TA to TSM 
          for distribution to TEE.
        </t>

        <figure>
          <preamble>The encryption algorithm can use a randomly AES 256 key 
          "taek" with a 16 byte random IV, and the "taek" is encrypted by the  
          "TEE SP AIK public key". The following encrypted TA data structure 
          is expected by TEE: </preamble>
        
          <artwork><![CDATA[
"encrypted_ta_bin": {
  "key": "<A 256-bit symmetric key encrypted by TEE SP AIK public 
           key>",
  "iv": <hex of 16 random bytes>",
  "alg": "AESCBC",
  "cipherdata": "<BASE64 encoded encrypted TA binary data>"
}
         ]]></artwork>
        </figure>

      </section>
      
      <section title="TA Personalization Data">
      <t>
        A SP or TSM can supply personalization data for a TA to initialize for
        a device. Such data is passed through InstallTA command from TSM. The
        personalization data itself is (or can be) opaque to the TSM. 
        The data can be from the SP without being revealed to the TSM. 
        The data is sent in encrypted manner in a
        request to a device such that only the device can decrypt. A device's
        TEE SP AIK public key for a SP is used to encrypt the data.
      </t>
      
        <figure>
          <artwork><![CDATA[
"encrypted_ta_data": { // "TA personalization data" 
    "key": "<A 256-bit symmetric key encrypted by TEE SP AIK public
            key>", 
    "iv": "<hex of 16 random bytes>",
    "alg": "AESCBC",
    "cipherdata": "<BASE64 encoded encrypted TA personalization 
                   data>" 
  }
         ]]></artwork>
        </figure>

      </section>

      <section title="TA trust check at TEE">
        <t>
        A TA binary is signed by a TA signer certificate. This TA signing
        certificate/private key belongs to the SP, and may be self-signed (i.e.
        it need not participate in a trust hierarchy). It is the responsibility
        of the TSM to only allow verified TAs from trusted SPs into the system.
        Delivery of that TA to the TEE is then the responsibility of the TEE,
        using the security mechanisms provided by the OTrP protocol. 
        </t>
      
        <t>
        We allow a way for application to check trustworthy of a TA. OTrP Agent
        will have a function to allow an application query the metadata of a TA.
        </t>
      
        <t>
          An application in the Rich O/S may perform verification of the TA by
          verifying the signature of the TA. The OTRPService.getTAInformation()
          function is available to return TEE supplied TA signer and TSM signer
          information to the application. An application can do additional
          trust check on the certificate returned for this TA. It may trust
          TSM, or require additional SP signer trust chaining.
        </t>
      </section>

      <section title="One TA Multiple SP Case">
        <t> A TA for different SP must have different identifier. A TA will be
        installed in different SD for the respective SP. </t>
      </section>

      <section title="OTrP Agent Trust Model">
        <t> An OTrP Agent could be malware in the vulnerable Android OS. A
        Client Application will connect its TSM provider for required TA
        installation. It gets command messages from TSM, and passes the message
        to the OTrP Agent. </t>
      
        <t> The OTrP protocol is a conduit for enabling the TSM to communicate
        with the device's TEE to manage SDs and TAs. All TSM messages are
        signed and sensitive data is encrypted such that the OTrP Agent cannot
        modify or capture sensitive data. </t>
      </section>

      <section title="OCSP Stapling Data for TSM signed messages">
        <t> The GetDeviceStateRequest message from TSM to TEE shall include
        OCSP stapling data for the TSM's signer certificate and that for
        intermediate CA certificates up to the root certificate so that the TEE
        side can verify the signer certificate's revocation status. </t>
      
        <t> Certificate revocation status check on a TA signer certificate is
        optional by a TEE. A TSM is generally expected to do proper TA
        application vetting and its SP signer trust validation. A TEE will
        trust a TA signer certificate's validation status done by a TSM when it
        trusts the TSM. </t>
      </section>

      <section title="Data protection at TSM and TEE">
        <t> The TEE implementation provides protection of data on the device. 
        It is the responsibility of the TSM to protect data on its servers. </t>
      </section>

      <section title="Privacy consideration">
        <t> Devices are issued with a unique TEE certificate to attest a device
        validity. This uniqueness also creates a privacy and tracking risk that
        must be mitigated. </t>
      
        <t> The TEE will only release the TEE certificate to a trusted TSM (it
        must verify the TSM certificate before proceeding). The OTrP protocol
        is designed such that only the TSM can obtain the TEE device
        certificate and firmware certificate - the GetDeviceState message
        requires signature checks to validate the TSM is trusted, and then
        delivers the device's certificate(s) encrypted such that only that TSM
        may decrypt the response. A Client Application will never see device
        certificate. </t>
      
        <t> A SP specific TEE SP AIK  (TEE SP Anonymous Key) is generated by
        the protocol for Client Applications. This provides a way for the
        Client Application to validate data sent from the TEE without requiring
        the TEE device certificate to be released to the client device rich O/S
        , and to optionally allow an SP to encrypt a TA for a target device
        without the SP needing to be supplied the TEE device certificate. </t>
      </section>

      <section title="Threat mitigation">
        <t> A rogue application may perform excessive TA loading. OTrP Agent
        implementation should protect against excessive calls. </t>
      
        <t> Rogue applications may request excessive SD creation request. The
        TSM is responsible to ensure this is properly guarded against. </t>
      
        <t> Rogue OTrP Agent could replay or send TSM messages out of
        sequence:e.g. TSM sends update1 and update2. OTrP Agent replays update2
        and update1 again, create unexpected result that client wants.
        "dsihash" is used to mitigate this. The TEE MUST make sure it stores
        DSI state and checks DSI state matches before it does another update.
        </t>
      
        <t> Concurrent calls from TSM to TEE should be handled properly by a
        TEE. It is up to the device to manage concurrency to the TEE. If
        multiple concurrent TSM operations take place these could fail due
        "dsihash" being modified by another concurrent operation. If locking is
        implemented on the client, this must be done in such a way that one
        application cannot lock other applications from using the TEE, except
        for a short term duration of the TSM operation taking place. For
        example, an OTrP operation that starts but never completes (e.g. loss
        of connectivity) must not prevent subsequent OTrP messages from being
        executed. </t>
      </section>

      <section title="Compromised CA">
        <t> If a root CA for TSM certificates is found compromised, some TEE
        trust anchor update mechanism should be devised. A compromised
        intermediate CA is covered by OCSP stapling and OCSP validation check
        in the protocol. A TEE should validate certificate revocation about a
        TSM certificate chain. </t>
      
        <t> If the root CA of some TEE device certificates is compromised,
        these devices might be rejected by TSM, which is a decision of TSM
        implementation and policy choice. Any intermediate CA for TEE device
        certificates should be validated by TSM with common CRL or OCSP method.
        </t>
      </section>

      <section title="Compromised TSM">
        <t> The TEE should use validation of the supplied TSM certificates and
        OCSP stapled data to validate that the TSM is trustworthy. </t>
      
        <t> Since PKI is used, the integrity of the clock within the TEE
        determines the ability of the TEE to reject an expired TSM certificate,
        or revoked TSM certificate. Since OCSP stapling includes signature
        generation time, certificate validity dates are compared to the current
        time. </t>
      </section>

      <section title="Certificate renewal">
        <t> TFW and TEE device certificates are expected to be long lived, longer than the
        lifetime of a device. A TSM certificate usually has a moderate 
        lifetime of 2 to 5 years. TSM should get renewed or rekeyed certificates.The root CA
        certificates for TSM, which is embedded into the trust anchor store in
        a device, should have long lifetime that don't require device trust
        anchor update. On the other hand, it is imperative that OEM or device
        providers plan for support of trust anchor update in their shipped
        devices. </t>
      </section>

    </section> <!-- Security Consideration -->



    
  </middle>

  <back>
    <references title="Normative References">
     &RFC2119;
     &RFC7515;
     &RFC7516; 
     &RFC7517;
     &RFC7518;
    </references>

    <references title="Informative References">
      <reference anchor="GPTEE">
        <front>
          <title>Global Platform, GlobalPlatform Device Technology:
            TEE System
            Architecture, v1.0</title>

          <author>
            <organization>Global Platform</organization>
          </author>
          <date year="2013" />
        </front>
      </reference>
    </references>

    <section anchor="samplemsgs" title="Sample Messages">
      <section title="Sample Security Domain Management Messages">
        <section title="Sample GetDeviceState">
          <section title="Sample GetDeviceStateRequest">
            <t>TSM builds a "GetDeviceStateTBSRequest" message.</t>

            <figure>
              <artwork><![CDATA[
{
    "GetDeviceStateTBSRequest": {
      "ver": "1.0",
      "rid": "8C6F9DBB-FC39-435c-BC89-4D3614DA2F0B",
      "tid": "4F454A7F-002D-4157-884E-B0DD1A06A8AE",
      "ocspdat": "c2FtcGxlIG9jc3BkYXQgQjY0IGVuY29kZWQgQVNOMQ==",
      "icaocspdat": "c2FtcGxlIGljYW9jc3BkYXQgQjY0IGVuY29kZWQgQVNOMQ==",
      "supportedsigalgs": "RS256"
    }
}
             ]]></artwork>
            </figure>
            
            <t>TSM signs "GetDeviceStateTBSRequest", creating
            "GetDeviceStateRequest"</t>

            <figure>
              <artwork><![CDATA[
{
  "GetDeviceStateRequest": {
    "payload":"
    ewoJIkdldERldmljZVN0YXRlVEJTUmVxdWVzdCI6IHsKCQkidmVyIjogIjEuMCIsCgkJ
    InJpZCI6IHs4QzZGOURCQi1GQzM5LTQzNWMtQkM4OS00RDM2MTREQTJGMEJ9LAoJCSJ0
    aWQiOiAiezRGNDU0QTdGLTAwMkQtNDE1Ny04ODRFLUIwREQxQTA2QThBRX0iLAoJCSJv
    Y3NwZGF0IjogImMyRnRjR3hsSUc5amMzQmtZWFFnUWpZMElHVnVZMjlrWldRZ1FWTk9N
    UT09IiwKCQkiaWNhb2NzcGRhdCI6ICJjMkZ0Y0d4bElHbGpZVzlqYzNCa1lYUWdRalkw
    SUdWdVkyOWtaV1FnUVZOT01RPT0iLAoJCSJzdXBwb3J0ZWRzaWdhbGdzIjogIlJTMjU2
    IgoJfQp9",
    "protected": "eyJhbGciOiJSUzI1NiJ9",
    "header": {
      "x5c": ["ZXhhbXBsZSBBU04xIHNpZ25lciBjZXJ0aWZpY2F0ZQ==",
              "ZXhhbXBsZSBBU04xIENBIGNlcnRpZmljYXRl"]
    },
    "signature":"c2FtcGxlIHNpZ25hdHVyZQ"
  }
}
             ]]></artwork>
            </figure>

          </section>
          <section title="Sample GetDeviceStateResponse">
            <t>TSM sends "GetDeviceStateRequest" to OTrP Agent</t>
            <t>OTrP Agent obtains "dsi" from each TEE. (in this example
            there is a single TEE).</t>
            <t>TEE obtains signed "fwdata" from firmware</t>
            <t>TEE builds "dsi" - summarizing device state of TEE</t>

            <figure>
              <artwork><![CDATA[
{
  "dsi": {
    "tfwdata": {
      "tbs": "ezRGNDU0QTdGLTAwMkQtNDE1Ny04ODRFLUIwREQxQTA2QThBRX0=",
      "cert": "ZXhhbXBsZSBGVyBjZXJ0aWZpY2F0ZQ==",
      "sigalg": "RS256",
      "sig": "c2FtcGxlIEZXIHNpZ25hdHVyZQ=="
    },
    "tee": {
      "name": "Primary TEE",
      "ver": "1.0",
      "cert": "c2FtcGxlIFRFRSBjZXJ0aWZpY2F0ZQ==",
      "cacert": [
        "c2FtcGxlIENBIGNlcnRpZmljYXRlIDE=",
        "c2FtcGxlIENBIGNlcnRpZmljYXRlIDI="
      ],
    "sdlist": {
      "cnt": "1",
      "sd": [
      {
        "name": "default.acmebank.com",
        "spid": "acmebank.com",
        "talist": [
          {
            "taid": "acmebank.secure.banking",
            "taname": "Acme secure banking app"
          },
          {
            "taid": "acmebank.loyalty.rewards",
            "taname": "Acme loyalty rewards app"
          }
        ]
      }
      ]
    },
    "teeaiklist": [
      {
        "spaik": "c2FtcGxlIEFTTjEgZW5jb2RlZCBQS0NTMSBwdWJsaWNrZXk=",
        "spaiktype": "RSA",
        "spid": "acmebank.com"
      }
    ]
    }
  }
}
             ]]></artwork>
            </figure>

            <t>TEE encrypts "dsi", and embeds into
              "GetDeviceTEEStateTBSResponse" message</t>

            <figure>
              <artwork><![CDATA[
{
  "GetDeviceTEEStateTBSResponse": {
    "ver": "1.0",
    "status": "pass",
    "rid": "{8C6F9DBB-FC39-435c-BC89-4D3614DA2F0B}",
    "tid": "{4F454A7F-002D-4157-884E-B0DD1A06A8AE}",
    "signerreq":"false",
    "edsi": {
      "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0K",
      "recipients": [
        {
          "header": {
          "alg": "RSA1_5"
        },
        "encrypted_key":
        "
        QUVTMTI4IChDRUspIGtleSwgZW5jcnlwdGVkIHdpdGggVFNNIFJTQSBwdWJsaWMg
        a2V5LCB1c2luZyBSU0ExXzUgcGFkZGluZw"
        }
      ],
      "iv": "ySGmfZ69YlcEilNr5_SGbA",
      "ciphertext":
      "
      c2FtcGxlIGRzaSBkYXRhIGVuY3J5cHRlZCB3aXRoIEFFUzEyOCBrZXkgZnJvbSByZW
      NpcGllbnRzLmVuY3J5cHRlZF9rZXk",
      "tag": "c2FtcGxlIGF1dGhlbnRpY2F0aW9uIHRhZw"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>TEE signs "GetDeviceTEEStateTBSResponse" and returns to
            OTrP Agent. OTrP Agent encodes "GetDeviceTEEStateResponse"
            into an array to form "GetDeviceStateResponse"</t>

            <figure>
              <artwork><![CDATA[
{
  "GetDeviceStateResponse": [
    {
      "GetDeviceTEEStateResponse": {
        "payload":
        "
        ewogICJHZXREZXZpY2VURUVTdGF0ZVRCU1Jlc3BvbnNlIjogewogICAgInZlciI6
        ICIxLjAiLAogICAgInN0YXR1cyI6ICJwYXNzIiwKICAgICJyaWQiOiAiezhDNkY5
        REJCLUZDMzktNDM1Yy1CQzg5LTREMzYxNERBMkYwQn0iLAogICAgInRpZCI6ICJ7
        NEY0NTRBN0YtMDAyRC00MTU3LTg4NEUtQjBERDFBMDZBOEFFfSIsCgkic2lnbmVy
        cmVxIjoiZmFsc2UiLAogICAgImVkc2kiOiB7CiAgICAgICJwcm90ZWN0ZWQiOiAi
        ZXlKbGJtTWlPaUpCTVRJNFEwSkRMVWhUTWpVMkluMEsiLAogICAgICAicmVjaXBp
        ZW50cyI6IFsKICAgICAgICB7CiAgICAgICAgICAiaGVhZGVyIjogewogICAgICAg
        ICAgImFsZyI6ICJSU0ExXzUiCiAgICAgICAgfSwKICAgICAgICAiZW5jcnlwdGVk
        X2tleSI6CiAgICAgICAgIgogICAgICAgIFFVVlRNVEk0SUNoRFJVc3BJR3RsZVN3
        Z1pXNWpjbmx3ZEdWa0lIZHBkR2dnVkZOTklGSlRRU0J3ZFdKc2FXTWcKICAgICAg
        ICBhMlY1TENCMWMybHVaeUJTVTBFeFh6VWdjR0ZrWkdsdVp3IgogICAgICAgIH0K
        ICAgICAgXSwKICAgICAgIml2IjogInlTR21mWjY5WWxjRWlsTnI1X1NHYkEiLAog
        ICAgICAiY2lwaGVydGV4dCI6CiAgICAgICIKICAgICAgYzJGdGNHeGxJR1J6YVNC
        a1lYUmhJR1Z1WTNKNWNIUmxaQ0IzYVhSb0lFRkZVekV5T0NCclpYa2dabkp2YlNC
        eVpXCiAgICAgIE5wY0dsbGJuUnpMbVZ1WTNKNWNIUmxaRjlyWlhrIiwKICAgICAg
        InRhZyI6ICJjMkZ0Y0d4bElHRjFkR2hsYm5ScFkyRjBhVzl1SUhSaFp3IgogICAg
        fQogIH0KfQ",
        "protected": "eyJhbGciOiJSUzI1NiJ9",
        "signature": "c2FtcGxlIHNpZ25hdHVyZQ"
      }
    }
  ]
}
             ]]></artwork>
            </figure>            

            <t>TEE returns "GetDeviceStateResponse" back to OTrP Agent,
            which returns message back to TSM.</t>

          </section>          
        </section>

        <section title="Sample CreateSD">
          <section title="Sample CreateSDRequest">

            <figure>
              <artwork><![CDATA[
{
  "CreateSDTBSRequest": { 
    "ver":"1.0",
    "rid":"req-01",
    "tid":"tran-01",
    "tee":"SecuriTEE",
    "nextdsi":"false",
    "dsihash":"Iu-c0-fGrpMmzbbtiWI1U8u7wMJE7IK8wkJpsVuf2js",
    "content":{   
      "spid":"bank.com",
      "sdname":"sd.bank.com",
      "spcert":"MIIDFjCCAn-
      gAwIBAgIJAIk0Tat0tquDMA0GCSqGSIb3DQEBBQUAMGwxCzAJBgNVBAYTAktSMQ4wD
      AYDVQQIDAVTZW91bDESMBAGA1UEBwwJR3Vyby1kb25nMRAwDgYDVQQKDAdTb2xhY2l
      hMRAwDgYDVQQLDAdTb2xhY2lhMRUwEwYDVQQDDAxTb2xhLWNpYS5jb20wHhcNMTUwN
      zAyMDg1MTU3WhcNMjAwNjMwMDg1MTU3WjBsMQswCQYDVQQGEwJLUjEOMAwGA1UECAw
      FU2VvdWwxEjAQBgNVBAcMCUd1cm8tZG9uZzEQMA4GA1UECgwHU29sYWNpYTEQMA4GA
      1UECwwHU29sYWNpYTEVMBMGA1UEAwwMU29sYS1jaWEuY29tMIGfMA0GCSqGSIb3DQE
      BAQUAA4GNADCBiQKBgQDYWLrFf2OFMEciwSYsyhaLY4kslaWcXA0hCWJRaFzt5mU-
      lpSJ4jeu92inBbsXcI8PfRbaItsgW1TD1Wg4gQH4MX_YtaBoOepE--
      3JoZZyPyCWS3AaLYWrDmqFXdbzaO1i8GxB7zz0gWw55bZ9jyzcl5gQzWSqMRpx_dca
      d2SP2wIDAQABo4G_MIG8MIGGBgNVHSMEfzB9oXCkbjBsMQswCQYDVQQGEwJLUjEOMA
      wGA1UECAwFU2VvdWwxEjAQBgNVBAcMCUd1cm8tZG9uZzEQMA4GA1UECgwHU29sYWNp
      YTEQMA4GA1UECwwHU29sYWNpYTEVMBMGA1UEAwwMU29sYS1jaWEuY29tggkAiTRNq3
      S2q4MwCQYDVR0TBAIwADAOBgNVHQ8BAf8EBAMCBsAwFgYDVR0lAQH_BAwwCgYIKwYB
      BQUHAwMwDQYJKoZIhvcNAQEFBQADgYEAEFMhRwEQ-
      LDa9O7P1N0mcLORpo6fW3QuJfuXbRQRQGoXddXMKazI4VjbGaXhey7Bzvk6TZYDa-
      GRiZby1J47UPaDQR3UiDzVvXwCOU6S5yUhNJsW_BeMViYj4lssX28iPpNwLUCVm1QV
      THILI6afLCRWXXclc1L5KGY290OwIdQ",
      "tsmid":"tsm_x.acme.com",
      "did":"zAHkb0-SQh9U_OT8mR5dB-tygcqpUJ9_x07pIiw8WoM"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>Here is a sample message after the content is encrypted
            and encoded</t>

            <figure>
              <artwork><![CDATA[
{
  "CreateSDRequest": {
  "payload":"
  eyJDcmVhdGVTRFRCU1JlcXVlc3QiOnsidmVyIjoiMS4wIiwicmlkIjoicmVxLTAxIiwidG
  lkIjoidHJhbi0wMSIsInRlZSI6IlNlY3VyaVRFRSIsIm5leHRkc2kiOiJmYWxzZSIsImRz
  aWhhc2giOiIyMmVmOWNkM2U3YzZhZTkzMjZjZGI2ZWQ4OTYyMzU1M2NiYmJjMGMyNDRlYz
  gyYmNjMjQyNjliMTViOWZkYTNiIiwiY29udGVudCI6eyJwcm90ZWN0ZWQiOiJlLUtBbkdW
  dVktS0FuVHJpZ0p4Qk1USTRRMEpETFVoVE1qVTI0b0NkZlEiLCJyZWNpcGllbnRzIjpbey
  JoZWFkZXIiOnsiYWxnIjoiUlNBMV81In0sImVuY3J5cHRlZF9rZXkiOiJTUzE2NTl4Q2FJ
  c1dUeUlsVTZPLUVsZzU4UUhvT1pCekxVRGptVG9vanBaWE54TVpBakRMcWtaSTdEUzhOVG
  FIWHcxczFvZjgydVhsM0d6NlVWMkRoZDJ3R2l6Y2VEdGtXc1RwZDg4QVYwaWpEYTNXa3lk
  dEpSVmlPOGdkSlEtV29NSUVJRUxzVGthblZCb25wQkF4ZHE0ckVMbl9TZlliaFg4Zm9ub2
  gxUVUifV0sIml2IjoiQXhZOERDdERhR2xzYkdsamIzUm9aUSIsImNpcGhlcnRleHQiOiI1
  bmVWZXdndm55UXprR3hZeWw5QlFrZTJVNjVaOHp4NDdlb3NzM3FETy0xY2FfNEpFY3NLcj
  ZhNjF5QzBUb0doYnJOQWJXbVRSemMwSXB5bTF0ZjdGemp4UlhBaTZBYnVSM2gzSUpRS1Bj
  UUVvRUlkZ2tWX0NaZTM2eTBkVDBpRFBMclg0QzFkb0dmMEdvaWViRC1yVUg1VUtEY3BsTW
  9lTjZvUnFyd0dnNUhxLTJXM3B4MUlzY0h4SktRZm11dkYxMTJ4ajBmZFNZX0N2WFE1NTJr
  TVRDUW1ZbzRPaGF2R0ZvaG9TZVVnaGZSVG1LYWp3OThkTzdhREdrUEpRUlBtYVVHWllEMW
  JXd01nMXFRV3RPd19EZlIyZDNzTzVUN0pQMDJDUFprVXBiQ3dZYVcybW9HN1c2Zlc2U3V5
  Q2lpd2pQWmZSQmIzSktTVTFTd1kxYXZvdW02OWctaDB6by12TGZvbHRrWFV2LVdPTXZTY0
  JzR25NRzZYZnMzbXlTWnJ1WTNRR09wVVRzdjFCQ0JqSTJpdjkwb2U2aXFCcVpxQVBxbzdi
  ajYwVlJGQzZPTlNLZExGQTIyU3pqRHo1dmtnTXNEaHkwSzlDeVhYN1Z6MkNLTXJvQjNiUE
  xFZF9abTZuVWlkTFN5cVJ5cXJxTmVnN1lmQng3aV93X0dzRW9rX1VYZXd6RGtneHp6RjZj
  XzZ6S0s3UFktVnVmYUo0Z2dHZmlpOHEwMm9RZ1VEZTB2Vm1FWDc0c2VQX2RxakVpZVVOYm
  xBZE9sS2dBWlFGdEs4dy1xVUMzSzVGTjRoUG9yeDc2b3lPVUpOQTVFZVV2Qy1jR2tMcTNQ
  UG1GRmQyaUtOTElCTEJzVWl6c1h3RERvZVA5SmktWGt5ZEQtREN1SHdpcno0OEdNNWVLSj
  Q5WVdqRUtFQko2T01NNUNmZHZ4cDNmVG1uUTdfTXcwZ3FZVDRiOUJJSnBfWjA3TTctNUpE
  emg0czhyU3dsQzFXU3V2RmhRWlJCcXJtX2RaUlRIb0VaZldXc1VCSWVNWWdxNG1zb0JqTj
  NXSzhnRWYwZGI5a3Z6UG9LYmpJRy10UUE2R2l1X3pHaFVfLXFBV1lLemVKMDZ6djRIWlBO
  dHktQXRyTGF0WGhtUTdOQlVrX0hvbjdOUWxhU1g1ZHVNVmN4bGs1ZHVrWFZNMDgxa09wYV
  kzbDliQVFfYVhTM0FNaFFTTVVsT3dnTDZJazFPYVpaTGFMLUE3ejlITnlESmFEWTVhakZK
  TWFDV1lfOG94YlNoQUktNXA2MmNuT0xzV0dNWWNKTlBGVTZpcWlMR19oc3JfNlNKMURhbD
  VtQ0YycnBJLUItMlhuckxZR01ZS0NEZ2V2dGFnbi1DVUV6RURwR3ozQ2VLcWdQU0Vqd3BK
  N0M3NXduYTlCSmtTUkpOdDNla3hoWElrcnNEazRHVVpMSDdQYzFYZHdRTXhxdWpzNmxJSV
  EycjM1NWEtVkotWHdPcFpfY3RPdW96LTA4WHdYQ3RkTEliSFFVTG40RjlMRTRtanU0dUxS
  bjNSc043WWZ1S3dCVmVEZDJ6R3NBY0s5SVlDa3hOaDk3dDluYW1iMDZqSXVoWXF5QkhWRU
  9nTkhici1rMDY1bW9OVk5lVVUyMm5OdVNKS0ZxVnIxT0dKNGVfNXkzYkNwTmxTeEFPV1Bn
  RnJzU0Flc2JJOWw4eVJtVTAwenJYdGc4OWt5SjlCcXN2eXA1RE8wX2FtS1JyMXB1MVJVWF
  lFZzB2ampKS1FSdDVZbXRUNFJzaWpqdGRDWDg3UUxJaUdSY0hDdlJzUzZSdDJESmNYR1ht
  UGQyc0ZmNUZyNnJnMkFzX3BmUHN3cnF1WlAxbVFLc3RPMFVkTXpqMTlyb2N1NHVxVXlHUD
  lWWU54cHVnWVdNSjRYb1dRelJtWGNTUEJ4VEtnenFPS2s3UnRzWWVMNXl4LVM4NjV0cHVz
  dTA0bXpzYUJRZ21od1ZFVXBRdWNrcG1YWkNLNHlJUXktaHNFQUlJSmVxdFB3dVAySXF0X2
  I5dlk0bzExeXdzeXhzdmp2RnNKN0VVZU1MaGE2R2dSanBSbnU5RWIzRnlJZ0U5M0VVNEEw
  T0lUMWlOSGNRYWc0eWtOc3dPdkxQbjZIZ21zQ05ESlgwekc2RlFDMTZRdjBSQ25SVTdfV2
  VvblhSTUZwUzZRZ1JiSk45R1NMckN5bklJSWxUcDBxNHBaS05zM0tqQ2tMUzJrb3Bhd2Y0
  WF9BUllmTko3a0s5eW5BR0dCcktnUWJNRWVxUEFmMDBKMlYtVXpuU1JMZmQ4SGs3Y2JEdk
  5RQlhHQW9BR0ViaGRwVUc0RXFwMlVyQko3dEtyUUVSRlh4RTVsOFNHY2czQ1RmN2Zoazdx
  VEFBVjVsWEFnOUtOUDF1c1ZRZk1fUlBleHFNTG9WQVVKV2syQkF6WF9uSEhkVVhaSVBIOG
  hLeDctdEFRV0dTWUd0R2FmanZJZzI2c082TzloQWZVd3BpSV90MzF6SkZORDU0OTZURHBz
  QmNnd2dMLU1UcVhCRUJ2NEhvQld5SG1DVjVFMUwiLCJ0YWciOiJkbXlEeWZJVlNJUi1Ren
  ExOEgybFRIeEMxbl9HZEtrdnZNMDJUcHdsYzQwIn19fQ",
  "protected":"e-KAnGFsZ-KAnTrigJxSUzI1NuKAnX0",    //RSAwithSHA256
  "header": {
    "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",             
      "signer":"
      MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcNMTUwNzAyMDkwMTE4Wh
      cNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5p
      YTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cy
      BQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
      meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
      AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA6b_ZI3
      c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
      ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX9nxZBNQWDjAJBgNVHR
      MEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAzANBgkq
      hkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4ivem4cIckfxzTBBiPHCjrrjB2X8Ktn8G
      SZ1MdyIZV8fwdEmD90IvtMHgtzK-
      9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fVrJvnYA
      UBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
        },
     "signature":"nuQUsCTEBLeaRzuwd7q1iPIYEJ2eJfurO5sT5Y-
     N03zFRcv1jvrqMHtx_pw0Y9YWjmpoWfpfelhwGEko9SgeeBnznmkZbp7kjS6MmX4CKz
     9OApe3-VI7yL9Yp0WNdRh3425eYfuapCy3lcXFln5JBAUnU_OzUg3RWxcU_yGnFsw"
  }
}
             ]]></artwork>
            </figure>
          
          </section>

          <section title="Sample CreateSDResponse">

            <figure>
              <artwork><![CDATA[
{
  "CreateSDTBSResponse": {
    "ver":"1.0",
    "status":"pass",
    "rid":"req-01",
    "tid":"tran-01",
    "content":{
      "did":"zAHkb0-SQh9U_OT8mR5dB-tygcqpUJ9_x07pIiw8WoM",
      "sdname":"sd.bank.com",
      "teespaik":"AQABjY9KiwH3hkMmSAAN6CLXot525U85WNlWKAQz5TOdfe_CM8h-
      X6_EHX1gOXoyRXaBiKMqWb0YZLCABTw1ytdXy2kWa525imRho8Vqn6HDGsJDZPDru9
      GnZR8pZX5ge_dWXB_uljMvDttc5iAWEJ8ZgcpLGtBTGLZnQoQbjtn1lIE",
    }
  }
}
             ]]></artwork>
            </figure>

            <t>Here is the response message after the content is
            encrypted and encoded.</t>
            
            <figure>
              <artwork><![CDATA[
{
  "CreateSDResponse": {
    "payload":"
    eyJDcmVhdGVTRFRCU1Jlc3BvbnNlIjp7InZlciI6IjEuMCIsInN0YXR1cyI6InBhc3Mi
    LCJyaWQiOiJyZXEtMDEiLCJ0aWQiOiJ0cmFuLTAxIiwiY29udGVudCI6eyJwcm90ZWN0
    ZWQiOiJlLUtBbkdWdVktS0FuVHJpZ0p4Qk1USTRRMEpETFVoVE1qVTI0b0NkZlEiLCJy
    ZWNpcGllbnRzIjpbeyJoZWFkZXIiOnsiYWxnIjoiUlNBMV81In0sImVuY3J5cHRlZF9r
    ZXkiOiJOX0I4R3pldUlfN2hwd0wwTFpHSTkxVWVBbmxJRkJfcndmZU1yZERrWnFGak1s
    VVhjdlI0XzhhOGhyeFI4SXR3aEtFZnVfRWVLRDBQb0dqQ2pCSHcxdG1ULUN6eWhsbW5v
    Slk3LXllWnZzRkRpc2VNTkd0eGE0OGZJYUs2VWx5NUZMYXBCZVc5T1I5bmktOU9GQV9j
    aFVuWWl3b2Q4ZTJFa0Vpd0JEZ1EzMk0ifV0sIml2IjoiQXhZOERDdERhR2xzYkdsamIz
    Um9aUSIsImNpcGhlcnRleHQiOiJsalh6Wk5JTmR1WjFaMXJHVElkTjBiVUp1RDRVV2xT
    QVptLWd6YnJINFVDYy1jMEFQenMtMWdWSFk4NTRUR3VMYkdyRmVHcDFqM2Fsb1lacWZp
    ZnE4aEt3Ty16RFlBN2tmVFhBZHp6czM4em9xeG4zbHoyM2w1RUlGUWhrOHBRWTRYTHRW
    M3ZBQWlNYnlrQ1Q3VS1CWDdWcjBacVNhYWZTQVZ4OFBLQ1RIU3hHN3hHVko0NkxxRzJS
    RE54WXQ4RC1SQ3lZUi1zRTM0MUFKZldEc2FLaGRRbzJXcjNVN1hTOWFqaXJtWjdqTlJ4
    cVRodHJBRWlIY1ctOEJMdVFHWEZ1YUhLMTZrenJKUGl4d0VXbzJ4cmw4cmkwc3ZRcHpl
    Z2M3MEt2Z0I0NUVaNHZiNXR0YlUya25hN185QU1Wcm4wLUJaQ1Bnb280MWlFblhuNVJn
    TXY2c2V2Y1JPQ2xHMnpWSjFoRkVLYjk2akEiLCJ0YWciOiIzOTZISTk4Uk1NQnR0eDlo
    ZUtsODROaVZLd0lJSzI0UEt2Z1RGYzFrbEJzIn19fQ",
    "protected": "e-KAnGFsZ-KAnTrigJxSUzI1NuKAnX0",
    "header": {
        "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",
        "signer":"
            MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJ
            BgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxp
            Zm9ybmlhMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcN
            MTUwNzAyMDkwMTE4WhcNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzET
            MBEGA1UECAwKQ2FsaWZvcm5pYTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8G
            A1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB
            AQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
            meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
            AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA
            6b_ZI3c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
            ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJ
            BgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxp
            Zm9ybmlhMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX
            9nxZBNQWDjAJBgNVHRMEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8E
            DDAKBggrBgEFBQcDAzANBgkqhkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4iv
            em4cIckfxzTBBiPHCjrrjB2X8Ktn8GSZ1MdyIZV8fwdEmD90IvtMHgtzK-
            9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fV
            rJvnYAUBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
    },
    "signature":"jnJtaB0vFFwrE-qKOR3Pu9pf2gNoI1s67GgPCTq0U-
    qrz97svKpuh32WgCP2MWCoQPEswsEX-nxhIx_siTe4zIPO1nBYn-
    R7b25rQaF87O8uAOOnBN5Yl2Jk3laIbs-
    hGE32aRZDhrVoyEdSvIFrT6AQqD20bIAZGqTR-zA-900"
  }
}
             ]]></artwork>
            </figure>
          </section>          
        </section>

        <section title="Sample UpdateSD">
          <section title="Sample UpdateSDRequest">
            <figure>
              <artwork><![CDATA[

{
  "UpdateSDTBSRequest": {
    "ver": "1.0",
    "rid": "1222DA7D-8993-41A4-AC02-8A2807B31A3A",
    "tid": "4F454A7F-002D-4157-884E-B0DD1A06A8AE",
    "tee": "Primary TEE ABC",
    "nextdsi": "false",
    "dsihash":
    "
    IsOvwpzDk8Onw4bCrsKTJsONwrbDrcKJYjVTw4vCu8OAw4JEw6zCgsK8w4JCacKxW8Kf
    w5o7",
    "content": { // NEEDS to BE ENCRYPTED
      "tsmid": "id1.tsmxyz.com",
      "spid": "com.acmebank.spid1",
      "sdname": "com.acmebank.sdname1",
      "changes": {
        "newsdname": "com.acmebank.sdname2",
        "newspid": "com.acquirer.spid1",
        "spcert":
        "MIIDFjCCAn-
        gAwIBAgIJAIk0Tat0tquDMA0GCSqGSIb3DQEBBQUAMGwxCzAJBgNVBAYTAktSMQ4
        wDAYDVQQIDAVTZW91bDESMBAGA1UEBwwJR3Vyby1kb25nMRAwDgYDVQQKDAdTb2x
        hY2lhMRAwDgYDVQQLDAdTb2xhY2lhMRUwEwYDVQQDDAxTb2xhLWNpYS5jb20wHhc
        NMTUwNzAyMDg1MTU3WhcNMjAwNjMwMDg1MTU3WjBsMQswCQYDVQQGEwJLUjEOMAw
        GA1UECAwFU2VvdWwxEjAQBgNVBAcMCUd1cm8tZG9uZzEQMA4GA1UECgwHU29sYWN
        pYTEQMA4GA1UECwwHU29sYWNpYTEVMBMGA1UEAwwMU29sYS1jaWEuY29tMIGfMA0
        GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDYWLrFf2OFMEciwSYsyhaLY4kslaWcXA0
        hCWJRaFzt5mU-
        lpSJ4jeu92inBbsXcI8PfRbaItsgW1TD1Wg4gQH4MX_YtaBoOepE--
        3JoZZyPyCWS3AaLYWrDmqFXdbzaO1i8GxB7zz0gWw55bZ9jyzcl5gQzWSqMRpx_d
        cad2SP2wIDAQABo4G_MIG8MIGGBgNVHSMEfzB9oXCkbjBsMQswCQYDVQQGEwJLUj
        EOMAwGA1UECAwFU2VvdWwxEjAQBgNVBAcMCUd1cm8tZG9uZzEQMA4GA1UECgwHU2
        9sYWNpYTEQMA4GA1UECwwHU29sYWNpYTEVMBMGA1UEAwwMU29sYS1jaWEuY29tgg
        kAiTRNq3S2q4MwCQYDVR0TBAIwADAOBgNVHQ8BAf8EBAMCBsAwFgYDVR0lAQH_BA
        wwCgYIKwYBBQUHAwMwDQYJKoZIhvcNAQEFBQADgYEAEFMhRwEQ-
        LDa9O7P1N0mcLORpo6fW3QuJfuXbRQRQGoXddXMKazI4VjbGaXhey7Bzvk6TZYDa
        -
        GRiZby1J47UPaDQR3UiDzVvXwCOU6S5yUhNJsW_BeMViYj4lssX28iPpNwLUCVm1
        QVTHILI6afLCRWXXclc1L5KGY290OwIdQ",
        "renewteespaik": "0"
      }
    }
  }
}
             ]]></artwork>
            </figure>
          
          </section>
          
          <section title="Sample UpdateSDResponse">
            <t></t>
            
            <figure>
              <artwork><![CDATA[
{
  "UpdateSDTBSResponse": {
    "ver": "1.0",
    "status": "pass",
    "rid": "1222DA7D-8993-41A4-AC02-8A2807B31A3A",
    "tid": "4F454A7F-002D-4157-884E-B0DD1A06A8AE",
    "content": {
      "did": "MTZENTE5Qzc0Qzk0NkUxMzYxNzk0NjY4NTc3OTY4NTI=",
      "teespaik":
      "AQABjY9KiwH3hkMmSAAN6CLXot525U85WNlWKAQz5TOdfe_CM8h-
      X6_EHX1gOXoyRXaBiKMqWb0YZLCABTw1ytdXy2kWa525imRho8Vqn6HDGsJDZPDru9
      GnZR8pZX5ge_dWXB_uljMvDttc5iAWEJ8ZgcpLGtBTGLZnQoQbjtn1lIE",
      "teespaiktype": "RSA"
    }
  }
}
             ]]></artwork>
            </figure>
          </section>
        </section>

        <section title="Sample DeleteSD">
          <section title="Sample DeleteSDRequest">
<t>TSM builds message - including data to be encrypted.</t>
            <figure>
              <artwork><![CDATA[
{
     "DeleteSDTBSRequest": {
       "ver": "1.0",
       "rid": "{712551F5-DFB3-43f0-9A63-663440B91D49}",
       "tid": "{4F454A7F-002D-4157-884E-B0DD1A06A8AE}",
       "tee": "Primary TEE",
       "nextdsi": "false",
       "dsihash": "AAECAwQFBgcICQoLDA0ODwABAgMEBQYHCAkKCwwNDg8=",
       "content": ENCRYPTED {
         "tsmid": "tsm1.com",
         "sdname": "default.acmebank.com",
         "deleteta": "1"
       }
     }
   }
             ]]></artwork>
            </figure>

            <t>TSM encrypts the "content".</t>
            
            <figure>
              <artwork><![CDATA[
{
  "DeleteSDTBSRequest": {
    "ver": "1.0",
    "rid": "{712551F5-DFB3-43f0-9A63-663440B91D49}",
    "tid": "{4F454A7F-002D-4157-884E-B0DD1A06A8AE}",
    "tee": "Primary TEE",
    "nextdsi": "false",
    "dsihash": "AAECAwQFBgcICQoLDA0ODwABAgMEBQYHCAkKCwwNDg8=",
    "content": {
    "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0",
    "recipients": [
      {
        "header": {
          "alg": "RSA1_5"
        },
      "encrypted_key":
      "
      QUVTMTI4IChDRUspIGtleSwgZW5jcnlwdGVkIHdpdGggVFNNIFJTQSBwdWJsaWMga2
      V5LCB1c2luZyBSU0ExXzUgcGFkZGluZw"
      }
    ],
    "iv": "rWO5DVmQX9ogelMLBIogIA",
    "ciphertext":
    "
    c2FtcGxlIGRzaSBkYXRhIGVuY3J5cHRlZCB3aXRoIEFFUzEyOCBrZXkgZnJvbSByZWNp
    cGllbnRzLmVuY3J5cHRlZF9rZXk",
    "tag": "c2FtcGxlIGF1dGhlbnRpY2F0aW9uIHRhZw"
    }
  }
}
             ]]></artwork>
            </figure>

            <t>TSM signs "DeleteSDTBSRequest" to form "DeleteSDRequest"</t>
            
            <figure>
              <artwork><![CDATA[
{
  "DeleteSDRequest": {
    "payload":"
    ewoJIkRlbGV0ZVNEVEJTUmVxdWVzdCI6IHsKCQkidmVyIjogIjEuMCIsCgkJInJp
    ZCI6ICJ7NzEyNTUxRjUtREZCMy00M2YwLTlBNjMtNjYzNDQwQjkxRDQ5fSIsCgkJ
    InRpZCI6ICJ7NEY0NTRBN0YtMDAyRC00MTU3LTg4NEUtQjBERDFBMDZBOEFFfSIs
    CgkJInRlZSI6ICJQcmltYXJ5IFRFRSIsCgkJIm5leHRkc2kiOiAiZmFsc2UiLAoJ
    CSJkc2loYXNoIjogIkFBRUNBd1FGQmdjSUNRb0xEQTBPRHdBQkFnTUVCUVlIQ0Fr
    S0N3d05EZzg9IiwKCQkiY29udGVudCI6IHsKCQkJInByb3RlY3RlZCI6ICJleUps
    Ym1NaU9pSkJNVEk0UTBKRExVaFRNalUySW4wIiwKCQkJInJlY2lwaWVudHMiOiBb
    ewoJCQkJImhlYWRlciI6IHsKCQkJCQkiYWxnIjogIlJTQTFfNSIKCQkJCX0sCgkJ
    CQkiZW5jcnlwdGVkX2tleSI6ICJRVVZUTVRJNElDaERSVXNwSUd0bGVTd2daVzVq
    Y25sd2RHVmtJSGRwZEdnZ1ZGTk5JRkpUUVNCd2RXSnNhV01nYTJWNUxDQjFjMmx1
    WnlCU1UwRXhYelVnY0dGa1pHbHVadyIKCQkJfV0sCgkJCSJpdiI6ICJyV081RFZt
    UVg5b2dlbE1MQklvZ0lBIiwKCQkJImNpcGhlcnRleHQiOiAiYzJGdGNHeGxJR1J6
    YVNCa1lYUmhJR1Z1WTNKNWNIUmxaQ0IzYVhSb0lFRkZVekV5T0NCclpYa2dabkp2
    YlNCeVpXTnBjR2xsYm5SekxtVnVZM0o1Y0hSbFpGOXJaWGsiLAoJCQkidGFnIjog
    ImMyRnRjR3hsSUdGMWRHaGxiblJwWTJGMGFXOXVJSFJoWnciCgkJfQoJfQp9",
    "protected":"eyJhbGciOiJSUzI1NiJ9",
    "header": {
      "x5c": ["ZXhhbXBsZSBBU04xIHNpZ25lciBjZXJ0aWZpY2F0ZQ==",
              "ZXhhbXBsZSBBU04xIENBIGNlcnRpZmljYXRl"]
    },
    "signature":"c2FtcGxlIHNpZ25hdHVyZQ"
  }
}
             ]]></artwork>
            </figure>

          </section>
          
          <section title="Sample DeleteSDResponse">
            <t>TEE creates "DeleteSDTBSResponse" to respond to the "DeleteSDRequest"
   message from the TSM, including data to be encrypted.</t>
            
            <figure>
              <artwork><![CDATA[
  {
     "DeleteSDTBSResponse": {
       "ver": "1.0",
       "status": "pass",
       "rid": "{712551F5-DFB3-43f0-9A63-663440B91D49}",
       "tid": "{4F454A7F-002D-4157-884E-B0DD1A06A8AE}",
       "content": ENCRYPTED {
         "did": "MTZENTE5Qzc0Qzk0NkUxMzYxNzk0NjY4NTc3OTY4NTI=",
       }
     }
   }
             ]]></artwork>
            </figure>


<t>TEE encrypts the "content" for the TSM.</t>

            <figure>
              <artwork><![CDATA[
   {
    "DeleteSDTBSResponse": {
     "ver": "1.0",
     "status": "pass",
     "rid": "{712551F5-DFB3-43f0-9A63-663440B91D49}",
     "tid": "{4F454A7F-002D-4157-884E-B0DD1A06A8AE}",
      "content": {
      "protected": "eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0K",
      "recipients": [
        {
          "header": {
          "alg": "RSA1_5"
        },
        "encrypted_key":
        "
        QUVTMTI4IChDRUspIGtleSwgZW5jcnlwdGVkIHdpdGggVFNNIFJTQSBwdWJsaWMg
        a2V5LCB1c2luZyBSU0ExXzUgcGFkZGluZw"
        }
      ],
      "iv": "ySGmfZ69YlcEilNr5_SGbA",
      "ciphertext":
      "
      c2FtcGxlIGRzaSBkYXRhIGVuY3J5cHRlZCB3aXRoIEFFUzEyOCBrZXkgZnJvbSByZW
      NpcGllbnRzLmVuY3J5cHRlZF9rZXk",
      "tag": "c2FtcGxlIGF1dGhlbnRpY2F0aW9uIHRhZw"
      }
     }
   }
             ]]></artwork>
            </figure>

            <t>TEE signs "DeleteSDTBSResponse" to form
            "DeleteSDResponse"</t>
            
            <!-- TBD The content doesn't look to be encrypted. 
                 Need encrypt the content first to get TBS request. -->
            
            <figure>
              <artwork><![CDATA[
{
  "DeleteSDResponse": {
    "payload":"
    ewoJIkRlbGV0ZVNEVEJTUmVzcG9uc2UiOiB7CgkJInZlciI6ICIxLjAiLAoJCSJz
    dGF0dXMiOiAicGFzcyIsCgkJInJpZCI6ICJ7NzEyNTUxRjUtREZCMy00M2YwLTlB
    NjMtNjYzNDQwQjkxRDQ5fSIsCgkJInRpZCI6ICJ7NEY0NTRBN0YtMDAyRC00MTU3
    LTg4NEUtQjBERDFBMDZBOEFFfSIsCgkJImNvbnRlbnQiOiB7CgkJCSJwcm90ZWN0
    ZWQiOiAiZXlKbGJtTWlPaUpCTVRJNFEwSkRMVWhUTWpVMkluMEsiLAoJCQkicmVj
    aXBpZW50cyI6IFt7CgkJCQkiaGVhZGVyIjogewoJCQkJCSJhbGciOiAiUlNBMV81
    IgoJCQkJfSwKCQkJCSJlbmNyeXB0ZWRfa2V5IjogIlFVVlRNVEk0SUNoRFJVc3BJ
    R3RsZVN3Z1pXNWpjbmx3ZEdWa0lIZHBkR2dnVkZOTklGSlRRU0J3ZFdKc2FXTWdh
    MlY1TENCMWMybHVaeUJTVTBFeFh6VWdjR0ZrWkdsdVp3IgoJCQl9XSwKCQkJIml2
    IjogInlTR21mWjY5WWxjRWlsTnI1X1NHYkEiLAoJCQkiY2lwaGVydGV4dCI6ICJj
    MkZ0Y0d4bElHUnphU0JrWVhSaElHVnVZM0o1Y0hSbFpDQjNhWFJvSUVGRlV6RXlP
    Q0JyWlhrZ1puSnZiU0J5WldOcGNHbGxiblJ6TG1WdVkzSjVjSFJsWkY5clpYayIs
    CgkJCSJ0YWciOiAiYzJGdGNHeGxJR0YxZEdobGJuUnBZMkYwYVc5dUlIUmhadyIK
    CQl9Cgl9Cn0",
    "protected":"eyJhbGciOiJSUzI1NiJ9",
    "signature":"c2FtcGxlIHNpZ25hdHVyZQ"
  }
}
             ]]></artwork>
            </figure>

            <t>TEE returns "DeleteSDResponse" back to OTrP Agent, which
            returns message back to TSM.</t>
          </section>
        </section>
        
      </section> <!-- SD Mgmt -->

      <section title="Sample TA Management Messages">
        <section title="Sample InstallTA">
          <section title="Sample InstallTARequest">
            <figure>
              <artwork><![CDATA[
{
  "InstallTATBSRequest": {
    "ver": "1.0",
    "rid": "24BEB059-0AED-42A6-A381-817DFB7A1207",
    "tid": "4F454A7F-002D-4157-884E-B0DD1A06A8AE",
    "tee": "Primary TEE ABC",
    "nextdsi": "true",
    "dsihash":
    "
    IsOvwpzDk8Onw4bCrsKTJsONwrbDrcKJYjVTw4vCu8OAw4JEw6zCgsK8w4JCacKxW8Kf
    w5o7",
    "content": {
      "tsmid": "id1.tsmxyz.com",
      "spid": "com.acmebank.spid1",
      "sdname": "com.acmebank.sdname1",
      "taid": "com.acmebank.taid.banking"
    },
    "encrypted_ta": {
      "key":
      "mLBjodcE4j36y64nC/nEs694P3XrLAOokjisXIGfs0H7lOEmT5FtaNDYEMcg9RnE
      ftlJGHO7N0lgcNcjoXBmeuY9VI8xzrsZM9gzH6VBKtVONSx0aw5IAFkNcyPZwDdZ
      MLwhvrzPJ9Fg+bZtrCoJz18PUz+5aNl/dj8+NM85LCXXcBlZF74btJer1Mw6ffzT
      /grPiEQTeJ1nEm9F3tyRsvcTInsnPJ3dEXv7sJXMrhRKAeZsqKzGX4eiZ3rEY+FQ
      6nXULC8cAj5XTKpQ/EkZ/iGgS0zcXR7KUJv3wFEmtBtPD/+ze08NILLmxM8olQFj
      //Lq0gGtq8vPC8r0oOfmbQ==",
      "iv": "4F5472504973426F726E496E32303135",
      "alg": "AESCBC",
      "ciphertadata":
      "......0x/5KGCXWfg1Vrjm7zPVZqtYZ2EovBow+7EmfOJ1tbk......=",
      "cipherpdata": "0x/5KGCXWfg1Vrjm7zPVZqtYZ2EovBow+7EmfOJ1tbk="
    }
  }
}
             ]]></artwork>
            </figure>
          </section>
          
          <section title="Sample InstallTAResponse">
            <t>A sample to-be-signed response of InstallTA looks as
            follows.</t>
            
            <figure>
              <artwork><![CDATA[
{
  "InstallTATBSResponse": {
    "ver": "1.0",
    "status": "pass",
    "rid": "24BEB059-0AED-42A6-A381-817DFB7A1207",
    "tid": "4F454A7F-002D-4157-884E-B0DD1A06A8AE",
    "content": {
      "did": "MTZENTE5Qzc0Qzk0NkUxMzYxNzk0NjY4NTc3OTY4NTI=",
      "dsi": {
        "tfwdata": {
          "tbs": "ezRGNDU0QTdGLTAwMkQtNDE1Ny04ODRFLUIwREQxQTA2QThBRX0="
          "cert": "ZXhhbXBsZSBGVyBjZXJ0aWZpY2F0ZQ==", 
          "sigalg": "UlMyNTY=",
          "sig": "c2FtcGxlIEZXIHNpZ25hdHVyZQ=="
        },
        "tee": {
          "name": "Primary TEE",
          "ver": "1.0",
          "cert": "c2FtcGxlIFRFRSBjZXJ0aWZpY2F0ZQ==",
          "cacert": [ 
            "c2FtcGxlIENBIGNlcnRpZmljYXRlIDE=", 
            "c2FtcGxlIENBIGNlcnRpZmljYXRlIDI="
          ],
          "sdlist": {
            "cnt": "1",
            "sd": [
              {
                "name": "com.acmebank.sdname1",
                "spid": "com.acmebank.spid1",
                "talist": [
                    {
                    "taid": "com.acmebank.taid.banking",
                    "taname": "Acme secure banking app"
                    },
                    {
                    "taid": "acom.acmebank.taid.loyalty.rewards",
                    "taname": "Acme loyalty rewards app"
                    }
                ]
              }
            ]
          },
          "teeaiklist": [
            {
              "spaik":
                "c2FtcGxlIEFTTjEgZW5jb2RlZCBQS0NTMSBwdWJsaWNrZXk=",
              "spaiktype": "RSA"
              "spid": "acmebank.com"
            }
          ]
        }
      }
    }
  }
}
             ]]></artwork>
            </figure>

          </section>
        </section>

        <section title="Sample UpdateTA">
          <section title="Sample UpdateTARequest">

            <t></t>
            
            <!-- comments from doc: 
            1. Document says to use hex encoding. 
            2. Secondly, the raw data should be 16 bytes.
            3. dsidash contains non legitimate character '_' for BASE64
            -->
            
            <figure>
              <artwork><![CDATA[
{
  "UpdateTATBSRequest": {
    "ver": "1.0",
    "rid": "req-2",
    "tid": "tran-01",
    "tee": "SecuriTEE",
                "nextdsi": " false",
    "dsihash": "gwjul_9MZks3pqUSN1-eL1aViwGXNAxk0AIKW79dn4U",
    "content": { 
      "tsmid": "tsm1.acme.com",
      "spid": "bank.com",
      "sdname": "sd.bank.com",          
      "taid": "sd.bank.com.ta"
    },
    "encrypted_ta": {
      "key":
      "
      XzmAn_RDVk3IozMwNWhiB6fmZlIs1YUvMKlQAv_UDoZ1fvGGsRGo9bT0A440aYMgLt
      GilKypoJjCgijdaHgamaJgRSc4Je2otpnEEagsahvDNoarMCC5nGQdkRxW7Vo2NKgL
      A892HGeHkJVshYm1cUlFQ-BhiJ4NAykFwlqC_oc",
      "iv": "AxY8DCtDaGlsbGljb3RoZQ",
      "alg": "AESCBC",
      "ciphernewtadata":
      "KHqOxGn7ib1F_14PG4_UX9DBjOcWkiAZhVE-U-
      67NsKryHGokeWr2spRWfdU2KWaaNncHoYGwEtbCH7XyNbOFh28nzwUmstep4nHWbAl
      XZYTNkENcABPpuw_G3I3HADo"
    }
  }
}
             ]]></artwork>
            </figure>

            <figure>
              <artwork><![CDATA[
{
  "UpdateTARequest": {
    "payload" :
    "
    eyJVcGRhdGVUQVRCU1JlcXVlc3QiOnsidmVyIjoiMS4wIiwicmlkIjoicmVxLTIiLCJ0
    aWQiOiJ0cmFuLTAxIiwidGVlIjoiU2VjdXJpVEVFIiwibmV4dGRzaSI6ImZhbHNlIiwi
    ZHNpaGFzaCI6Imd3anVsXzlNWmtzM3BxVVNOMS1lTDFhVml3R1hOQXhrMEFJS1c3OWRu
    NFUiLCJjb250ZW50Ijp7InByb3RlY3RlZCI6ImV5SmxibU1pT2lKQk1USTRRMEpETFVo
    VE1qVTJJbjAiLCJyZWNpcGllbnRzIjpbeyJoZWFkZXIiOnsiYWxnIjoiUlNBMV81In0s
    ImVuY3J5cHRlZF9rZXkiOiJYem1Bbl9SRFZrM0lvek13TldoaUI2Zm1abElzMVlVdk1L
    bFFBdl9VRG9aMWZ2R0dzUkdvOWJUMEE0NDBhWU1nTHRHaWxLeXBvSmpDZ2lqZGFIZ2Ft
    YUpnUlNjNEplMm90cG5FRWFnc2FodkROb2FyTUNDNW5HUWRrUnhXN1ZvMk5LZ0xBODky
    SEdlSGtKVnNoWW0xY1VsRlEtQmhpSjROQXlrRndscUNfb2MifV0sIml2IjoiQXhZOERD
    dERhR2xzYkdsamIzUm9aUSIsImNpcGhlcnRleHQiOiJIYTcwVXRZVEtWQmtXRFJuMi0w
    SF9IdkZtazl5SGtoVV91bk1OLWc1T3BqLWF1NGFUb2lxWklMYzVzYTdENnZZSjF6eW04
    QW1JOEJIVXFqc2l5Z0tOcC1HdURJUjFzRXc0a2NhMVQ5ZENuU0RydHhSUFhESVdrZmt3
    azZlR1NQWiIsInRhZyI6Im9UN01UTE41eWtBTFBoTDR0aUh6T1pPTGVFeU9xZ0NWaEM5
    MXpkcldMU0UifSwiZW5jcnlwdGVkX3RhIjp7ImtleSI6Ilh6bUFuX1JEVmszSW96TXdO
    V2hpQjZmbVpsSXMxWVV2TUtsUUF2X1VEb1oxZnZHR3NSR285YlQwQTQ0MGFZTWdMdEdp
    bEt5cG9KakNnaWpkYUhnYW1hSmdSU2M0SmUyb3RwbkVFYWdzYWh2RE5vYXJNQ0M1bkdR
    ZGtSeFc3Vm8yTktnTEE4OTJIR2VIa0pWc2hZbTFjVWxGUS1CaGlKNE5BeWtGd2xxQ19v
    YyIsIml2IjoiQXhZOERDdERhR2xzYkdsamIzUm9aUSIsImFsZyI6IkFFU0NCQyIsImNp
    cGhlcm5ld3RhZGF0YSI6IktIcU94R243aWIxRl8xNFBHNF9VWDlEQmpPY1draUFaaFZF
    LVUtNjdOc0tyeUhHb2tlV3Iyc3BSV2ZkVTJLV2FhTm5jSG9ZR3dFdGJDSDdYeU5iT0Zo
    MjhuendVbXN0ZXA0bkhXYkFsWFpZVE5rRU5jQUJQcHV3X0czSTNIQURvIn19fQ",
    "protected": " eyJhbGciOiJSUzI1NiJ9",
    "header": {
      "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",
      "signer":"
      MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcNMTUwNzAyMDkwMTE4Wh
      cNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5p
      YTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cy
      BQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
      meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
      AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA6b_ZI3
      c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
      ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX9nxZBNQWDjAJBgNVHR
      MEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAzANBgkq
      hkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4ivem4cIckfxzTBBiPHCjrrjB2X8Ktn8G
      SZ1MdyIZV8fwdEmD90IvtMHgtzK-
      9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fVrJvnYA
      UBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
    },
    "signature":"inB1K6G3EAhF-
    FbID83UI25R5Ao8MI4qfrbrmf0UQhjM3O7_g3l6XxN_JkHrGQaZr-
    myOkGPVM8BzbUZW5GqxNZwFXwMeaoCjDKc4Apv4WZkD1qKJxkg1k5jaUCfJz1Jmw_XtX
    6MHhrLh9ov03S9PtuT1VAQ0FVUB3qFIvjSnNU"
  }
}
             ]]></artwork>
            </figure>

          </section>
          
          <section title="Sample UpdateTAResponse">
            <figure>
              <artwork><![CDATA[
{
  "UpdateTATBSResponse": {
    "ver": "1.0",
    "status": "pass",
        "rid": "req-2",
        "tid": "tran-01",
        "content": {
      "did": "zAHkb0-SQh9U_OT8mR5dB-tygcqpUJ9_x07pIiw8WoM"
    }
  }
}
             ]]></artwork>
            </figure>
            
            <figure>
              <artwork><![CDATA[
{
  "UpdateTAResponse":{
    "payload":"
    eyJVcGRhdGVUQVRCU1Jlc3BvbnNlIjp7InZlciI6IjEuMCIsInN0YXR1cyI6InBhc3Mi
    LCJyaWQiOiJyZXEtMiIsInRpZCI6InRyYW4tMDEiLCJjb250ZW50Ijp7InByb3RlY3Rl
    ZCI6ImV5SmxibU1pT2lKQk1USTRRMEpETFVoVE1qVTJJbjAiLCJyZWNpcGllbnRzIjpb
    eyJoZWFkZXIiOnsiYWxnIjoiUlNBMV81In0sImVuY3J5cHRlZF9rZXkiOiJFaGUxLUJB
    UUdJLTNEMFNHdXFGY01MZDJtd0gxQm1uRndYQWx1M1FxUFVXZ1RRVm55SUowNFc2MnBK
    YWVSREFkeTU0R0FSVjBrVzQ0RGw0MkdUUlhqbE1EZ3BYdXdFLWloc1JVV0tNNldCZ2N3
    VXVGQTRUR3gwU0I1NTZCdl92dnBNaFdfMXh2c2FHdFBaQmwxTnZjbXNibzBhY3FobXlu
    bzBDTmF5SVAtX1UifV0sIml2IjoiQXhZOERDdERhR2xzYkdsamIzUm9aUSIsImNpcGhl
    cnRleHQiOiJwc2o2dGtyaGJXM0lmVElMeE9GMU5HdFUtcTFmeVBidV9KWk9jbklycWIw
    eTNPOHN6OTItaWpWR1ZyRW5WbG1sY1FYeWFNZTNyX1JGdEkwV3B4UmRodyIsInRhZyI6
    Ik0zb2dNNk11MVJYMUMybEZvaG5rTkN5b25qNjd2TDNqd2RrZXhFdUlpaTgifX19",
    "protected":"eyJhbGciOiJSUzI1NiJ9",
    "header": {
      "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",
      "signer":"
      MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcNMTUwNzAyMDkwMTE4Wh
      cNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5p
      YTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cy
      BQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
      meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
      AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA6b_ZI3
      c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
      ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX9nxZBNQWDjAJBgNVHR
      MEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAzANBgkq
      hkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4ivem4cIckfxzTBBiPHCjrrjB2X8Ktn8G
      SZ1MdyIZV8fwdEmD90IvtMHgtzK-
      9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fVrJvnYA
      UBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
    },
    "signature":"
    Twajmt_BBLIMcNrDsjqr8lI7O7lEQxXZNhlUOtFkOMMqf37wOPKtp_99LoS82CVmdpCo
    PLaws8zzh-SNIQ42-
    9GYO8_9BaEGCiCwyl8YgWP9fWNfNv2gR2fl2DK4uknkYu1EMBW4YfP81n_pGpb4Gm-
    nMk14grVZygwAPej3ZZk"
  }
}
             ]]></artwork>
            </figure>
          </section>
        </section>

        <section title="Sample DeleteTA">
          <section title="Sample DeleteTARequest">

            <t></t>
            
            <figure>
              <artwork><![CDATA[
{
  "DeleteTATBSRequest": {
    "ver": "1.0",
    "rid": "req-2",
    "tid": "tran-01",
    "tee": "SecuriTEE",
    "nextdsi": "false",
    "dsihash": "gwjul_9MZks3pqUSN1-eL1aViwGXNAxk0AIKW79dn4U",
    "content": {
      "tsmid": "tsm1.acme.com",
      "sdname": "sd.bank.com",
      "taid": "sd.bank.com.ta"
    }
  }
}
             ]]></artwork>
            </figure>

            <figure>
              <artwork><![CDATA[
{
  "DeleteTARequest": {
    "payload":
    "
    eyJEZWxldGVUQVRCU1JlcXVlc3QiOnsidmVyIjoiMS4wIiwicmlkIjoicmVxLTIiLCJ0
    aWQiOiJ0cmFuLTAxIiwidGVlIjoiU2VjdXJpVEVFIiwibmV4dGRzaSI6ImZhbHNlIiwi
    ZHNpaGFzaCI6Imd3anVsXzlNWmtzM3BxVVNOMS1lTDFhVml3R1hOQXhrMEFJS1c3OWRu
    NFUiLCJjb250ZW50Ijp7InByb3RlY3RlZCI6eyJlbmMiOiJBMTI4Q0JDLUhTMjU2In0s
    InJlY2lwaWVudHMiOlt7ImhlYWRlciI6eyJhbGciOiJSU0ExXzUifSwiZW5jcnlwdGVk
    X2tleSI6ImtyaGs0d2dpY0RlX3d0VXQyTW4tSUJsdUtvX0JkeXpNY2p1cVlBenBPYnRS
    TG9MZzQ0QkFLN2tRVWE1YTg0TEVJRGEzaHNtWDIxdldNZFJLczN4MTJsOUh5VFdfLUNS
    WmZtcUx2bEh1LV9MSVdvc1ZyRTZVMlJqUnRndllVOWliUkVLczkzRDRHWm4xVHFuZG9n
    d0tXRF9jdG1nWG1sbzZZVXpCWDZhR1dZMCJ9XSwiaXYiOiJBeFk4REN0RGFHbHNiR2xq
    YjNSb1pRIiwiY2lwaGVydGV4dCI6IkhhNzBVdFlUS1ZCa1dEUm4yLTBIX1BGa19yQnpQ
    dGJHdzhSNktlMXotdklNeFBSY0Nxa1puZmwyTjRjUTZPSTZCSHZJUUFoM2Jic0l0dHlR
    bXhDTE5Nbm8wejBrYm9TdkIyVXlxWExpeGVZIiwidGFnIjoidEtUbFRLdlR2LTRtVVlG
    Y1dYWnZMMVlhQnRGNloxVlNxOTMzVmI2UEpmcyJ9fX0",
    "protected" : "eyJhbGciOiJSUzI1NiJ9",
    "header":   {
      "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",
      "signer":"
      MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcNMTUwNzAyMDkwMTE4Wh
      cNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5p
      YTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8GA1UECgwYSW50ZXJuZXQgV2lkZ2l0cy
      BQdHkgTHRkMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
      meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
      AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA6b_ZI3
      c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
      ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJBgNVBA
      YTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxpZm9ybmlhMSEw
      HwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX9nxZBNQWDjAJBgNVHR
      MEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8EDDAKBggrBgEFBQcDAzANBgkq
      hkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4ivem4cIckfxzTBBiPHCjrrjB2X8Ktn8G
      SZ1MdyIZV8fwdEmD90IvtMHgtzK-
      9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fVrJvnYA
      UBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
    },
    "signature" :
    "
    BZS0_Ab6pqvGNXe5lqT4Sc3jakyWQeiK9KlVSnimwWnjCCyMtyB9bwvlbILZba3IJiFe
    _3F9bIQpSytGS0f2TQrPTKC7pSjwDw-3kH7HkHcPPJd-
    PpMMfQvRx7AIV8vBqO9MijIC62iN0V2se5z2v8VFjGSoRGgq225w7FvrnWE"
  }
}
             ]]></artwork>
            </figure>
          </section>
          
          <section title="Sample DeleteTAResponse">
            <figure>
              <artwork><![CDATA[
{
  "DeleteTATBSResponse": {
    "ver": "1.0",
    "status": "pass",
        "rid": "req-2",
        "tid": "tran-01",
        "content": {
      "did": "zAHkb0-SQh9U_OT8mR5dB-tygcqpUJ9_x07pIiw8WoM"
    }
  }
}             ]]></artwork>
            </figure>

            <t></t>
            
            <figure>
              <artwork><![CDATA[
{
  "DeleteTAResponse":{
    "payload":"
    ew0KCSJEZWxldGVUQVRCU1Jlc3BvbnNlIjogew0KCQkidmVyIjogIjEuMCIsDQoJCSJz
    dGF0dXMiOiAicGFzcyIsDQoJCSJyaWQiOiAicmVxLTIiLA0KCQkidGlkIjogInRyYW4t
    MDEiLA0KCQkiY29udGVudCI6IHsNCgkJCSJwcm90ZWN0ZWQiOnsiZW5jIjoiQTEyOENC
    Qy1IUzI1NiJ9LA0KCQkJInJlY2lwaWVudHMiOlsNCgkJCQl7DQoJCQkJCSJoZWFkZXIi
    OnsiYWxnIjoiUlNBMV81In0sDQoJCQkJCSJlbmNyeXB0ZWRfa2V5IjoiTXdtU1ZHaWU2
    eHpfQmxTaFlmTFRKRHhKT3oyNWhvYy1HZ2NEM2o5OWFyM2E4X2lYY182ZE44bFRTb1dD
    X19wZEFhaEMyWk5SakdIcTBCZ2JDYTRKalk0eXRkMVBVWDB6M1psbXl1YnRXM291eEpY
    el9PMzg1WGM4S3hySndjbElyZGx2WUY2OVZmeERLQkVzUHJCdzlVenVIa1VmSU4xWlFU
    bWZ0QmVaSlJnIg0KCQkJCX0NCgkJCV0sDQoJCQkiaXYiOiJBeFk4REN0RGFHbHNiR2xq
    YjNSb1pRIiwNCgkJCSJjaXBoZXJ0ZXh0IjoiamhQTlV5ZkFTel9rVV9GbEM2LUtCME01
    WDBHNE5MbHc0LWt0bERyajZTWlUteUp6eUFUbC1oY0ZBWWMwLXJMVEF4cF93N1d1WER0
    Y3N3SzJSSzRjcWciLA0KCQkJInRhZyI6IlBBeGo5N25oT29qVTNIREhxSll4MGZMNWpt
    b0xkTlJkTHRtSmIzUTdrYXciDQoJCX0NCgl9DQp9",
    "protected": "eyJhbGciOiJSUzI1NiJ9",
    "header": {
      "kid":"e9bc097a-ce51-4036-9562-d2ade882db0d",
      "signer":"
      MIIC3zCCAkigAwIBAgIJAJf2fFkE1BYOMA0GCSqGSIb3DQEBBQUAMFoxCzAJ
      BgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxp
      Zm9ybmlhMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGQwHhcN
      MTUwNzAyMDkwMTE4WhcNMjAwNjMwMDkwMTE4WjBaMQswCQYDVQQGEwJVUzET
      MBEGA1UECAwKQ2FsaWZvcm5pYTETMBEGA1UEBwwKQ2FsaWZvcm5pYTEhMB8G
      A1UECgwYSW50ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIGfMA0GCSqGSIb3DQEB
      AQUAA4GNADCBiQKBgQC8ZtxM1bYickpgSVG-
      meHInI3f_chlMBdL8l7daOEztSs_a6GLqmvSu-
      AoDpTsfEd4EazdMBp5fmgLRGdCYMcI6bgpO94h5CCnlj8xFKPq7qGixdwGUA
      6b_ZI3c4cZ8eu73VMNrrn_z3WTZlExlpT9XVj-
      ivhfJ4a6T20EtMM5qwIDAQABo4GsMIGpMHQGA1UdIwRtMGuhXqRcMFoxCzAJ
      BgNVBAYTAlVTMRMwEQYDVQQIDApDYWxpZm9ybmlhMRMwEQYDVQQHDApDYWxp
      Zm9ybmlhMSEwHwYDVQQKDBhJbnRlcm5ldCBXaWRnaXRzIFB0eSBMdGSCCQCX
      9nxZBNQWDjAJBgNVHRMEAjAAMA4GA1UdDwEB_wQEAwIGwDAWBgNVHSUBAf8E
      DDAKBggrBgEFBQcDAzANBgkqhkiG9w0BAQUFAAOBgQAGkz9QpoxghZUWT4iv
      em4cIckfxzTBBiPHCjrrjB2X8Ktn8GSZ1MdyIZV8fwdEmD90IvtMHgtzK-
      9wo6Aibj_rVIpxGb7trP82uzc2X8VwYnQbuqQyzofQvcwZHLYplvi95pZ5fV
      rJvnYAUBFyfrdT5GjqL1nqH3a_Y3QPscuCjg"
    },
    "signature":"
    DfoBOetNelKsnAe_m4Z9K5UbihgWNYZsp5jVybiI05sOagDzv6R4do9npaAlAvpNK8HJ
    CxD6D22J8GDUExlIhSR1aDuDCQm6QzmjdkFdxAz5TRYl6zpPCZqgSToN_g1TZxqxEv6V
    Ob5fies4g6MHvCH-Il_-KbHq5YpwGxEEFdg"
  }
}
             ]]></artwork>
            </figure>
          </section>
        </section>
        
      </section> <!-- TA Mgmt -->
    </section>
  </back>
</rfc>
